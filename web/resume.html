<!doctype html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="resume.css" rel="stylesheet">
<!-- <script src="utils/sticky-sidebar.js"></script>  -->
<script src="utility.js"></script>
<script src="resume.js"></script>
<title>陈军 - 个人简历</title>
</head>

<!-- ====================================================================== -->

<body>
<div id="css_layout_now">
	<!-- Use this empty ele to know whether we are in mobile layout or desktop layout at any specific time. -->
</div>

<div class="floatbartray">
	<div class="floatbarframe">
		<div class="floatbaricon">
		</div>
	</div>
</div>

<div class="globalframe">

<div class="maincol titlebar">
	<div class="titlebar__head">个人简历</div>
	<div class="titlebar__myname">
		<span class="chenjun">陈军</span>
		<span class="career">软件工程师</span>
	</div>
</div>

<div class="sidecol clearfix">
	<!-- 
		When in mobile layout, display beneath the .titlebar .
		When in desktop layout, display as right-hand "fixed" side-column.
	 -->
	<div class="langsel">
		<button id="btn-cn" class="langbtn langbtn__left button_on"><span>中文</span></button>
		<button id="btn-en" class="langbtn langbtn__right"><span>English</span></button>
	</div>
	<div class="portrait"></div>
	<div class="profile_scrollbox">
		<div class="profile_list" expandable_fixed_childs="5" expandable_curtain_childs="2">
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">姓名</div>
					<div class="lang-en0">Name</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">陈军</div>
					<div class="lang-en0">Jimm Chen</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">出生日期</div>
					<div class="lang-en0">Born</div>
				</div>
				<div class="item__value">
					1980.04.29
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">家乡</div>
					<div class="lang-en0">Hometown</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">中国, 福建, 福州</div>
					<div class="lang-en0">Fuzhou, Fujian, China</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">手机</div>
					<div class="lang-en0">Cellphone</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">13705034343</div>
					<div class="lang-en0">+86-13705034343</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">电子邮箱</div>
					<div class="lang-en0">Email</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">653707736@qq.com<br/>chjfth@gmail.com</div>
					<div class="lang-en0">653707736@qq.com<br/>chjfth@gmail.com</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">毕业院校</div>
					<div class="lang-en0">Graduated</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">厦门大学(本科)</div>
					<div class="lang-en0">Xiamen University (Bachelor)</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">工作经验</div>
					<div class="lang-en0">Working Experience</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">16 年</div>
					<div class="lang-en0">16 years</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">期望的工作</div>
					<div class="lang-en0">Expected jobs</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">有关软件开发的，有创造性的</div>
					<div class="lang-en0">Software development related, with creativity</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">期望工作地点</div>
					<div class="lang-en0">Expected job location</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">大城市</div>
					<div class="lang-en0">In mega city</div>
				</div>
			</div>
			<div class="profile__item">
				<div class="item__name">
					<div class="lang-cn0">More...期望工作地点</div>
					<div class="lang-en0">...Expected job location</div>
				</div>
				<div class="item__value">
					<div class="lang-cn0">More...大城市</div>
					<div class="lang-en0">...In mega city</div>
				</div>
			</div>
		</div>
	</div> <!-- .profile_scrollbox -->
	
	<div class="tocframe">
		<div class="toctitle">
			<div class="lang-cn0">目录列表</div>
			<div class="lang-en0">Table of Content</div>
			<div class="toctitle_arrow svg_arrowup"></div>
		</div>
		<div class="toctext">
			To be filled by js code.
		</div>
	</div>
	
</div> <!-- End of .sidecol -->

<div class="maincol">

	<!-- ========== h1title ========== -->
	<h1 class="h1title">
		<div class="lang-cn0">心智与性格</div>
		<div class="lang-en0">Mindset and Personality</div>
		<div class="stripe"></div>
	</h1>
	<div class="duallang">
		<div class="lang-cn2">人类社会进步的标志，在于将自己的想法不断地变成现实。</div>
		<div class="lang-en2">Human society moves forward, with our continuous effort turning our ideas into reality.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">人生的意义在于探索世界运行的规律、创造美好的事物。</div>
		<div class="lang-en2">The meaning of life, is to explorer rules of the world, and to create beautiful things.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我是个诚实正直的人，虚伪和欺骗会让我很不自在。</div>
		<div class="lang-en2">I'm an honest and decent person, going untruthful and deceitful makes me uncomfortable.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我是九型人格中的 5 号、1 号 和 6 号。</div>
		<div class="lang-en2">I'm #5, #1 and #6 according to Enneagram.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我乐于了解新鲜的事物，因为每样事物看起来对这个世界都有它存在的意义。</div>
		<div class="lang-en2">I'm always ready to learn new things, since everything that exists has its own significance to this world.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我有写日记和工作记录的习惯，因为记忆对我来说很宝贵。</div>
		<div class="lang-en2">I have the habit of writing diary and working records, because memory is vital to my life.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我希望做能够为人们带来长久益处的工作。</div>
		<div class="lang-en2">I wish to be engaged in works that can bring people long-term benefits.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我希望我的工作伙伴能够分享他们的知识和经验，因为我自己一直就是这么做的。一个开放源代码的工作环境我会特别喜欢。</div>
		<div class="lang-en2">I wish my workmates have a passion for sharing their knowledge and experience, because I myself have done this all the way. An open-source environment is especially welcome.</div>
	</div>
	<div class="duallang">
		<div class="lang-cn2">我一直在收集软件开发中的最佳实践.。最佳实践，是让程序员的生活变得越来越有趣的重要因素。</div>
		<div class="lang-en2">I'm always collecting best practices in software development. Best practices are what make a programmer's life more and more intriguing.</div>
	</div>

	<!-- ========== h1title ========== -->
	<h1 class="h1title">
		<div class="lang-cn0">工作经验</div>
		<div class="lang-en0">Working Experience</div>
		<div class="stripe"></div>
	</h1>
	
	<div class="careerbanner">
		<div class="careerb__orgname">
			<div class="duallang">
				<div class="lang-cn0">福建新大陆识别技术有限公司</div>
				<div class="lang-en0">Fujian Newland Auto-ID Tech. Co.,Ltd.</div>
			</div>
		</div>
		<div class="careerb__jobtitle">
			<div class="duallang">
				<div class="lang-cn0">软件工程师</div>
				<div class="lang-en0">Software Engineer</div>
			</div>
		</div>
		<div class="careerb__date">
			<div class="duallang">
				<div class="lang-both">
					2002.07 ~ 2018.06
				</div>
			</div>
		</div>
	</div>

	<div class="companyinfo">
		<div class="duallang">
			<div class="lang-cn2"><a href="http://www.nlscan.com" target="_blank">福建新大陆识别技术有限公司</a>成立于 1999 年，是业界知名的条码采集器和试读引擎的生产商，是国内最早拥有条形码编码和解码自主知识产权技术的公司，现已在欧洲、北美、台湾设有分公司，拥有来自世界各地的客户。</div>
			<div class="lang-en2"><a href="http://www.nlscan.com" target="_blank">Fujian Newland Auto-ID Tech. Co.,Ltd.</a> was founded in 1999. She is a well known barcode reading engine and terminal manufacturer in the barcode technology industry, the first domestic company to have fully owned intellectual proprietary on barcode encoding and decoding, and now has subsidiaries in Europe, North America and Taiwan, with customers from all around the world. </div>
		</div>
	</div>
	
	<div class="careertable">  <!-- expandable_fixed_childs="160px" expandable_curtain_childs="40px" -->
	
		<div class="careertable__row careertable__headrow">
			<div class="careertable__date">
				<div class="duallang headtext">
					<div class="lang-cn0">时间线</div>
					<div class="lang-en0">Timeline</div>
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang headtext">
					<div class="lang-cn0">成就</div>
					<div class="lang-en0">Achievement</div>
				</div>
			</div>
			<div class="careertable__skill">
				<div class="duallang headtext">
					<div class="lang-cn0">技能</div>
					<div class="lang-en0">Skills</div>
				</div>
			</div>
		</div>
	
		<div class="careertable__row">
			<div class="careertable__date">
				2015.10 ~ 2018.06<br>UFCOM driver
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">潜心开发 UFCOM 虚拟串口驱动程序，这是我的第一个 Windows 驱动程序作品，靠一己之力完成。它拥有多项独创功能和优秀的易用性，超越了我所知的所有业界竞争对手的同类软件，我甚至觉得，可以用近些年的网络流行语“碾压”来形容。</div>
					<div class="lang-en2">Developing my first Window driver software, called UFCOM. I finished this work entirely on my own. It has many unique features with excellent usability, overwhelmingly surpassing all counterparts that I knew at the time of its completion.</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>C/C++</li>
					<li>USB protocol</li>
					<li>Windows Kernel</li>
					<li>WinAPI</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__date">
				2006.02 ~ 2016.04<br>GMU
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">十年间，我持续地改进着我的 C/C++ 工程自动构建系统，称作 GMU ，完整名称 GnumakeUniproc，因为这套系统是基于 GNU make 开发的。这套系统让我能够从源代码服务器构建我遇到的各式各样的 C++ 工程，你可以认为这是一套持续继承(CI)的工具。我的工作过程会用到各种厂商的 C++ 编译器，有本地编译的，也有交叉编译的，因此我觉得需要维护一套自己的构建系统来应对各种复杂的构建需求。
				 </div>
					<div class="lang-en2">For ten years, I intermittently develop my own C/C++-projects build system called GMU(full name is GnumakeUniproc), based on GNU make, so that I can automatically build various C++ projects from source-control system. You can think of it as a continuous integration(CI) tool. I have come up with all kinds of C++ projects with C++ compilers from various vendors, native and cross-platform; so I have a strong need to maintain a build system so that I can keep my sanity. 
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">没错，UFCOM 就是用 GMU 来自动构建的。在构建机器上敲一个起始命令行，然后所有源代码将从服务器上取出，最终自动生成 msi 安装包。在使用 GMU 管理 UFCOM 构建过程的期间，GMU 自身、以及我的函数库管理思想同时也经历了很大的改进。</div>
					<div class="lang-en2">Yes, UFCOM is built with GMU. With one starting command-line, the build machine will checkout all source files from server and the final msi installer package is generated. This guarantees no manual build error could slip in. During the course of managing UFCOM building with GMU, GMU itself and my idea of managing function libraries went through big enhancements.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">在 SourceForge.net 上能够<a href="https://sourceforge.net/projects/gnumakeuniproc/" target="_blank">取到</a> GMU 的源代码和版本记录。 虽然 GMU 在我的软件生涯中起了非常巨大的作用，但目前看起来其他人对它并没有兴趣，也许是用起来有些复杂。</div>
					<div class="lang-en2">GMU's source code and version history can be <a href="https://sourceforge.net/projects/gnumakeuniproc/" target="_blank">acquired</a> from SourceForge.net . Frankly speaking, although I consider GMU very useful in my software career, no other tends to use it, perhaps due to its complexity.
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>GNU make</li>
					<li>Bash scripting</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__date">
				2003 ~ 2016<br>PT-850
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">改进与维护一款手持数据采集器产品(型号: PT-850 系列)的内核固件，直至其 2016 年生命周期完结。主要内容是添加各种硬件设备的驱动程序，串口硬件、Wi-Fi 模块、NAND Flash、USB 从属端控制器等。这些代码绝大多数由我亲自编写，而非在他人原有的代码上修修补补。</div>
					<div class="lang-en2">Improve and maintain kernel firmware for a portable scanner(model name: PT-850 series), until its end-of-life in year 2016. Primary works involve adding device driver for various hardware peripherals such as Serial port, Wi-Fi module, NAND Flash and finally USB slave-side controller. I wrote most of these code myself, not just patching existing code from others.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">由于我同时进行 USB 主控端和从属端的设备驱动程序开发，因此我能够了解很多 USB 协议工作的细节，有利于双向功能验证和 bug 修正。</div>
					<div class="lang-en2">Since I do both Host-side and Slave-side driver coding, I know quite some details of the USB protocol. It helps a lot to verify each other, find and fix bugs.</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Embedded System</li>
					<li>Hardware programming</li>
					<li>TCP/IP</li>
					<li>802.11 protocol</li>
					<li>USB protocol</li>
					<li>API design</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__date">
				2005 ~ 2014
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">改进与维护用于 PT850 的 Windows-PC 端 SDK 与配套工具。包括：</div>
					<div class="lang-en2">Improve and maintain Windows-PC side SDK and utilities for PT-850. These mainly includes:</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">uTools：一个 Visual C++ 6.0 IDE 中的插件，用于生成 PT-850 的应用程序。其中调用了 ARM 目标编译器来生成 PT850 物理机上的可执行程序，以及调用 Visual C++ 编译器来生成 PC 端的模拟器程序。</div>
					<div class="lang-en2">uTools: As a Visual C++ 6.0 IDE Add-in, it calls ARM-targeted compiler to generate executables run by PT850 physical machine, and calls Visual C++ compiler to generate simulator programs that can be run on Windows.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">uEasyFile: 一套文件传输程序和 SDK。它使得用户能够在 Windows PC 和 PT-850 之间双向拷贝文件。</div>
					<div class="lang-en2">uEasyFile: A file transfer program and SDK. This enables users to copy files between Windows PC and PT-850.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">这些项目由我的同事启动，我后来接管了这些项目，做了大量的改进。</div>
					<div class="lang-en2">These projects are launched by my colleges, and I took them over and made quite a lot of improvements.</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>WinAPI</li>
					<li>API design</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__date">
				2009 ~ 2015
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">实施了一系列的软件开发相关的 IT 管理动作。作为软件开发工程师，我需要主动参与 IT 管理，是因为我们公司人员比较少（100~200），很长一段时间没有专职的 IT 管理人员。简要罗列如下：</div>
					<div class="lang-en2">Engaged in software-development related IT management. I did it because our company is small(100~200 total employees), and there was no dedicated IT management staff for quite long. A brief list below:</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">2006: 部署公司范围内的 Subversion 服务器，作为源码版本仓库，替换掉过时的 CVS 和 Visual Sourcesafe。接下来的十年，我持续地升级 Subversion 版本，从 1.4 到 1.9，在此期间，用 Python 脚本编写了一些有用的钩子程序来方便管理。</div>
					<div class="lang-en2">2006: Deploy Apache-based Subversion server as company-wide code repository, replacing the outdated CVS and Visual Sourcesafe. I keep upgrading it all the way from 1.4 to 1.9 during the next 10 years. During this course, I made quite some Python hook scripts to ease my management work.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">2007-2014: 安装与维护 Atlassian Confluence 文档协作平台，供公司内部员工交流与交换信息，版本号从 2.7 一路升级到 4.3，此间我见证了 Confluence 的巨大功能改进。我自己在内部 Confluence 上贡献了大量的技术文章。</div>
					<div class="lang-en2">2007-2014: Install and maintain Atlassian Confluence collaboration platform, for staff communication. During these years, I upgraded the Confluence software all the way from 2.7 to 4.3, witnessing its big improvements. I myself contributed lots of tech articles on this platform.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">2009-2013: 为公司的服务器主机引入服务器虚拟化。我从 VMware ESX 3.5U2 开始使用，后来升级到 ESXi 4.1 和 6.0。回到 2009 年，那是我已经有很多年借助 VMware workstation 进行软件开发的经验，因此开始部署时我就有很大的信心能够成功。</div>
					<div class="lang-en2">2009-2013: Introduce server virtualization to our company. I started from VMware ESX 3.5U2, later to ESXi 4.1 and 6.0. Back in 2009, I had used VMware workstation for development for a long time, so I had great confidence for that success.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">2009: 利用 Windows Server 2003 建立了 WPA2 Enterprise Wifi 网络，这使得公司能够部署安全接入的 Wifi 网络，同时，也能提供给移动采集器作为测试环境。</div>
					<div class="lang-en2">2009: Setup WPA2 Enterprise Wifi network using Windows Server 2003, so that employees can have a securely accessed Wifi network. It also provides a testing environment for mobile data terminals.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">2009-2015: 设法让各个服务器平台集成 Windows 活动目录身份验证功能——包括所有上头提及的服务器软件。如此一来，员工只需要记住一套用户名和密码即可访问那些服务。客观地说，这对于我的好处是，不用经常帮忘记密码的员工去重设密码了，节省出大量时间。</div>
					<div class="lang-en2">2009-2015: Enable Windows Active Directory authentication integration for various server software -- including all those mentioned above, so that the staffs can use one set of username/password to login to those services. Sure, it relieves me from constantly being requested to reset their forgotten password, a big timer saver.</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Windows Server</li>
					<li>VMware ESXi</li>
					<li>Subversion</li>
					<li>Apache httpd</li>
					<li>Python</li>
				</ul>
			</div>
		</div>

	</div>

	<!-- ========== h1title ========== -->
	<h1 class="h1title">
		<div class="lang-cn0">我的程序员生活</div>
		<div class="lang-en0">My life as a Programmer</div>
		<div class="stripe"></div>
	</h1>

	<div class="h1intro">
		<div class="duallang">
			<div class="lang-cn2">程序员改变世界。做一个程序员是幸运的，因为我们可以用编程技能来达成很多期望，这些期望在外行的眼中或者太浪费时间、或者太浪费金钱。不过呢，平庸的程序员（多年前就被叫做“码农”的那种吧）也许不会想那么多，他们只是将写代码当作获取薪水的手段罢了。我想我肯定不是那种人，也不应该是那种人。</div>
			<div class="lang-en2">Programmers change the world. Being a programmer can be lucky, because we can use programming skills to fulfill many expectations, which would otherwise be too time consuming or too costly. However, many average programmers, joked as "coding coolie" from many years ago, may not think so, as they consider programming only the way to get their salaries. I don't think I am, or should be, that kind of person.</div>
		</div>
		
		<div class="duallang">
			<div class="lang-cn2">每项技艺都有它的亮点。如果你能找到在生活中应用它的方法，生活就能充满乐趣。</div>
			<div class="lang-en2">Every feat has its own point. If you find ways to apply it to life, your life will be enlightened.</div>
		</div>
	</div>


	<div class="careertable"> <!-- careertable, life as a programmer -->
	
		<div class="careertable__row careertable__headrow">
			<div class="careertable__year">
				<div class="duallang headtext">
					<div class="lang-cn0">时间线</div>
					<div class="lang-en0">Timeline</div>
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang headtext">
					<div class="lang-cn0">有用的程序作品</div>
					<div class="lang-en0">Programming Artifacts</div>
				</div>
			</div>
			<div class="careertable__skill">
				<div class="duallang headtext">
					<div class="lang-cn0">技能</div>
					<div class="lang-en0">Skills</div>
				</div>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__year">
				<div class="duallang">
					<div class="lang-cn2">2019 ~ <br>您看到的这份双语简历</div>
					<div class="lang-en2">2019 ~ <br>This very dual-language résumé </div>
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">一个可工作的产品胜过千言万语。我花费了几个月时间，系统地（重新）学习了 Web 前端开发的关键技术，这才呈现出这份双语简历。为了吸引您的注意力，我觉得需要让自己表现得独特一些。
					</div>
					<div class="lang-en2">A workable product is worth a thousand words. I have spent several months to systematically (re-)learn the key ideas of Web front-end development, so that I can present the dual-language résumé. To get your attraction, I think I need to be something unique.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">这份网页版简历现在既有交互性也有敏感性，可以在桌面版或移动版浏览器上查看，阅读的视觉体验应该是不错的、甚至还有点吸引人。对于这篇冗长的文章，你也许可以边查阅边玩弄它，数一数我给这个网页设计了多少有趣的功能。
					</div>
					<div class="lang-en2">It is now interactive and responsive, can be viewed on desktop browser or mobile browser, and should be visually comfortable, or even attractive. I hope you can have something to play with when viewing this long or maybe boring article -- I mean, counting how many features I have designed into this webpage. 
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>HTML</li>
					<li>CSS</li>
					<li>Javascript</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__year">
				<div class="duallang">
					2016 ~ <br>pyscreencast
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">这是一个用 Python 实现的简易屏幕广播软件，并且带有简单的文本交换功能。</div>
					<div class="lang-en2">This is a simple screen casting software, implemented in Python, additionally with simple text exchange feature.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">想象一下，我们正在进行一场小型的会议或讲座，演讲者希望将自己的屏幕演示内容实时分享给参会者，有什么简单易行的方法呢？ Pyscreencast 就是为了这种场景而开发的，演讲者的电脑上运行 pyscreencast 服务端，参会者用手机/平板/电脑访问服务端的网址，即可实时同步显示演讲者的屏幕画面。
					</div>
					<div class="lang-en2">Imagine, we are having a small meeting or lecture, and the presenter hopes to share his screen to all attenders. What is the convenient way to do so? Pyscreencast does it. The presenter runs pyscreencast server side program from his PC, and the attenders visit server-side web address from their cellphone/tablet/PC and they see the synchronized screen shot from the presenter.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">这对于参会者显然有不少好处。比如，他不需要担心自己的座位离投影屏幕太远而看不清屏幕画面。他还可以将感兴趣的内容截屏保存到本机以便稍后回看。我还准备了一个文本通道，让演讲者能够将文字内容推送给听众。</div>
					<div class="lang-en2">There are quite some benefits for the attender, right? He does not need to worry about sitting too far way from the projected screen to see clearly. He can screen-shot content of interest for later review at will. Their is also a text broadcast channel that the presenter can push a bunch of text to all users. </div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">最有用的特点是它简洁的运行模型。演讲者无需购买任何服务，参会者也无需安装任何客户端软件。只要有一个局域网即可以工作。
					</div>
					<div class="lang-en2">The best is its concise working model, presenter don't have to buy any services, and the attenders don't have to install extra Apps on their devices. It works as long as you have a LAN.
					</div>
				</div>
				<div class="imagerow">
					<div>
						<img src="res/pyscreencast2016-server-side.png"/>
					</div>
					<div>
						<img src="res/pyscreencast2016-client-side.jpg"/>
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Python</li>
					<li>Web frontend</li>
				</ul>
			</div>
		</div>
	
		<div class="careertable__row">
			<div class="careertable__year">
				<div class="duallang">
					<div class="lang-cn2">2016 ~ <br>video_transcode.py</div>
					<div class="lang-en2">2019 ~ <br>视频转码脚本</div>
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">这是用 Python 编写的一个提效脚本，用于将大码率的视频转码为小码率的，节省存储空间。
					</div>
					<div class="lang-en2">This is a wrapper script written in Python bringing me efficiency. It transcode large-bitrate videos into small ones, so to conserve disk storage.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">我有录制电视节目的习惯，用视频捕捉卡、采集盒等，有时也用 iPad 和手机拍摄视频。然而，这些设备录下的视频文件原始尺寸都太大了(H.264 10Kbit/秒的位率)，太占用硬盘空间，因此我得让他们的尺寸小一些以便长期留存。而且，留存前通常还需要将电视广告等无意义的画面给裁掉。这些重复性的工作通常会消耗很多人力时间，因此我需要设计一套工具来让人力开销最少。
					</div>
					<div class="lang-en2">I have the habit of saving TV programs with a video capturing/recording device, and sometimes shot video with my iPad or cellphone. However, the initially recorded file size is very large(H.264 video bitrate 10Kbit/sec), too hard-disk space consuming, so I need to make it smaller for long-term preserving. Furthermore, the captured video needs some trimming, for example, cutting off TV ads and some meaningless scenes. These are daily human actions, so that I have to design a tool to do it effectively.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">我最终想到的方法是用命令行，在命令行上指定需要重新编码的位率、指定需留存内容的时间段，回车执行，等待它转码完成即可，相当地省心了。在没有这套工具之前，用基于图形界面的编辑工具真是太浪费时间了，就像在浪费生命。现在，我的命令行样子如下：
					</div>
					<div class="lang-en2">My final decision is: Use command-line. Key in desired bit-rate, time-ranges as command-line parameters, then Enter to execute, waiting it to be finished, quite a relief. Earlier, I used GUI-based video editing tools, too time consuming just like wasting my life. Now, my command-line is like this:
					</div>
				</div>
				<div class="duallang">
					<pre>transcode_hdtv.py -o final.mp4 -b 900 I:\201906102312250.ts[-1629][1736-]</pre>
				</div>
				<div class="duallang">
					<div class="lang-cn2">意思是，将 .ts 文件从 <u>00:00~16:29</u> 和 <u>17:36~结束</u>这两段内容转码成 900kbps 的 final.mp4 。显然，16:29~17:36 是被我裁掉的广告内容。命令行格式是我自己设计的，以符合我的效率需要，我的 Python 包装器内部，真正的转码工作是借助 ffmpeg 和 HandbrakeCLI 来完成的。</div>
					<div class="lang-en2">It means, transcode two parts of the .ts input(<u>00:00~16:29</u> and <u>17:36~end</u>) into a single final.mp4, with video bitrate of 900kbps. You can imagine that content between 16:29~17:36 is the TV ad to reject. I design command-line format to meet my own efficiency requirements; inside my python wrapper, I call ffmpeg and HandbrakeCLI to carry out the actual transcoding work.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">还有最后一个效率瓶颈需要解答，我是如何快速准确生成 "[-1629][1736-]" 这截参数的？倘若我仅仅是从视频播放器 UI 上将时间值抄到命令行上，那将很容易犯错。实施上我借助了 Autohotkey 脚本，帮我抓取 MPC-HC 显示的时间值并形成参数。下图示意了操作方法。
					</div>
					<div class="lang-en2">There is a final efficiency bottleneck left. How do I quickly and accurately produce time ranges like "[-1629][1736-]"? Actually, I turn to Autohotkey scripting for help. Autohotkey can grab time value displayed by MPC-HC video player, so that time ranges can be constructed. It works as illustrated below.
					</div>
				</div>
				<div class="imagerow">
					<div>
						<img src="res/mpchc-end1.jpg"/>
					</div>
					<div>
						<img src="res/mpchc-start2.jpg"/>
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Python</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__year">
				<div class="duallang">
					<div class="lang-cn2">2015 ~ <br>提高日常效率的 Autohotkey 脚本集</div>
					<div class="lang-en2">2015 ~ <br>Autohotkey scripts for daily efficiency</div>
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">对于每天都要在电脑面前探索世界、学习新知的我来说，使用电脑的效率让我觉得很重要，包括：高效地使用快捷键，高效地记录与组织信息等。我发现 <a href="https://www.autohotkey.com/" target="_blank">Autohotkey</a>(简称 AHK) 是个非常厉害的工具，它的可编程特性以及和 Windows API 的深度绑定使得我能够用简短的脚本来达成原本得费力写 C++ 程序才能达成的目的。上一节介绍的，用 ahk 来抓取视频播放器当前时间点就是个好例子。
					</div>
					<div class="lang-en2">As a guy exploring the world and learning new things everyday in front of a computer, I have a strong trend for efficiency. I find that <a href="https://www.autohotkey.com/" target="_blank">Autohotkey</a>(abbreviated as AHK) is a great tool. Its programmability feature and deep Windows API binding enables me to attain many goals that would otherwise require verbose C++ programming. In previous section, using ahk to grab time point from a video player is a good example.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">使用 ahk 的方法可以很简单，比如用 PrintScreen/ScrollLock 两个键盘按键来代替鼠标左键/右键点击，Ctrl+V 来粘贴文本到 CMD 窗口（在 Win10 内置该支持以前），强行抓取文本控件和列表框中文字（因为你没法 Ctrl+C 将它们拷出），还有很多很多。</div>
					<div class="lang-en2">Usage of ahk can be very simple, such as Using PrintScreen/ScrollLock keys for mouse left/right click, Ctrl+V to paste into Windows CMD box(before Win10 supports it natively), grabbing text from Windows static text labels and list boxs(because you just can't Ctrl+C to get them), and lots and lots.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">Autohotkey 脚本也可以强大到让人吃惊。比如，我这些年就写了很多 ahk 脚本来增强 Evernote 的使用体验，因为 Windows 版的 Evernote 客户端是我日常记录与整理知识的工具。举两个例子吧。
					</div>
					<div class="lang-en2">Autohotkey script can be astonishingly powerful as well. Recent years, I wrote many scripts to enhance Evernote's using experience. I did it because I use Evernote Windows desktop client app daily(currently using version 6.5.4) to record and organize my learning. Let me show you two examples.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">【例子一: EverTable】 插入色彩丰富的表格。你见过下面这种色彩的 Evernote 表格吗？Evernote 客户端自带的功能可做不到，用我的 ahk 脚本就可以做到，这也多亏了 Evernote 的内容引擎实际上是和 HTML 查看器/编辑器，我们只要往里头粘贴合规的 CF_HTML 内容，即可让 Evernote 呈现。我太需要这个上色功能了，因为我的结构化的知识都是用表格来组织的，使用丰富的颜色可以让我更快地找到目标帖子。</div>
					<div class="lang-en2">【Example One: EverTable】 Insert colorful table. Have you ever seen an Evernote table in such color? Evernote official client app does not give you that benefit. But with the help of my ahk script, it comes to true. Thanks to Evernote content engine actually being a HTML viewer/editor, so, we can paste into CF_HTML content then Evernote shows it as desired. I need this coloring feature so much, because I tends to organize structural knowledges with table, so abundant color scheme helps me pinpoint my saved clips much more faster.</div>
				</div>
				<div class="imagerow">
					<div>
						<img src="res/EverTable-GUI.png"/>
					</div>
					<div>
						<img src="res/EverTable-dualcolor-sample.png"/>
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">【例子二: Everpic】 将尺寸最适合的图片格式插入 Evernote。不知你是否注意到，使用 Windows Evernote 客户端，将一张剪贴板中的图片粘贴入 Evernote 帖子时，Evernote 是用什么格式来存储它的。事实上，Evernote 总会用 32-bit png 来存储，好处是不失真，坏处嘛，就是当我们不需要留存很多图片细节时（比如一幅风景画），使用 jpg 能够比 png 节省几倍到十几倍的空间。我觉得我有权力选择最空间利用率最佳的格式来存储我的信息。Evernote 官方客户端本身无此功能，好在 ahk 脚本能够帮我达成。Everpic 是这么工作的，当我有图片需要粘贴时，我不是直接 Ctrl+V 粘贴，而是先用一个热键启动 Everpic UI，Everpic 用多种编码格式来压缩当前剪贴板中的图形，我可以预览每一种格式的显示质量和尺寸，然后选择最佳的那个进行粘贴。哈，做一个明白人真好。
					</div>
					<div class="lang-en2">【Example Two: Everpic】 Pick the best image format to store. Have you ever wonder, when pasting an image into Evernote clip, what image-storing format is used? Actually, Evernote always use 32-bit png, which has the advantage of non-lossy encoding. However, sometimes we prefer lossy encoding in favor of smaller storage size. For example, storing a outdoor scenery picture with jpg format can result in several times or even ten more times storage saving. I think I should have the right to choose the most storage-effective format. Again, Evernote official client app does not provide this facility, and Autohotkey scripts again comes to help. Everpic works like this: When I want to paste a new picture, instead of doing Ctrl+V instantly, I use my hotkey to bring up Everpic UI, who encodes the image with multiple formats, then I can preview the image quality and their respective sizes, picking the best one to paste. Ha, it's a breeze to be a bright person.
					</div>
				</div>
				<div class="imagerow">
					<div>
						<img src="res/Everpic-preview.jpg"/>
					</div>
					<div>
						<img src="res/Everpic-inserted-into-Evernote.jpg"/>
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">上方左图是 Everpic 预览对话框，显示了各种图片压缩参数对应的文件大小；上方右图是猴子图片插入 Evernote 编辑窗口后的样子。
					</div>
					<div class="lang-en2">Above left is Everpic preview dialog, with file sizes of various image compressing parameters; above right is Evernote editing window with the monky image inserted.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">从上方的 Everpic 预览画面可以看出，对于猴子 SPA 这个风景画，60% 质量的 jpg 所用空间要比 32-bit png 小了十倍以上，而画面细节并无明显损失。Everpic 还带来一个额外好处，它帮我自动给图片添加了一段脚注文本，告知此图片的存储格式以及存储大小，还有该图片粘入的日期。
					</div>
					<div class="lang-en2">You see from above Everpic preview UI, for the monkey SPA picture, jpg with 60% quality is over ten times storage effective than 32-bit png, without much detail lost. With Everpic, I get an extra bonus, a footnote text is appended to indicate the image format and its storage size, as well as its pasting date.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">最后我还想补充一点：我写了很多的 ahk 脚本，有条理地组织它们成为一个需要考虑的问题。还好，我找到了模块化的方法，意思是，我将不同功能的脚本归类到不同的 ahk 文件中成为不同的模块，并且可以用一个配置文件来指示 Autohotkey 程序启动时需要装载哪些模块。这样一来，ahk 脚本就可以在团队间共享了，团队成员不用太担心自己的模块会和其他成员的冲突，会导致冲突的，不要去装载即可。
					</div>
					<div class="lang-en2">
					Final point deserved to say: I have written quite a lot ahk scripts, so organizing them becomes an issue. I managed to find a way to modulize them. I place different-purpose scripts into different .ahk files as different modules, and a configuration files tells what modules to load on Autohotkey startup. In this way, ahk scripts can be shared among team members, not much worry about script conflicts, because, end-user can set-aside those conflicting ones on his own.
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">下方，左图是配置文件的样子，它告知应该装载哪些 ahk 模块。右图是 Autohotkey 程序启动时的反馈，，告知哪些模块已经被装载了。</div>
					<div class="lang-en2">Below: Left image is the configuration file determine what ahk "modules" to load. Right image is the feedback info on Autohotkey program startup, telling what modules have been loaded.</div>
				</div>
				<div class="imagerow">
					<div>
						<img src="res/ahk-includes-cfg.png"/>
					</div>
					<div>
						<img src="res/ahk-includes-loaded.png"/>
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Autohotkey</li>
				</ul>
			</div>
		</div>

		<div class="careertable__row">
			<div class="careertable__year">
				<div class="duallang">
					2015 ~ <br>Easytmux
				</div>
			</div>
			<div class="careertable__achievement">
				<div class="duallang">
					<div class="lang-cn2">Easytmux 这个名字暗示，它是让 <a href="https://github.com/tmux/tmux" target="_blank">tmux</a> 变得十分易用的一个小工具。Tmux 称它自己是“终端复用器”，从技术角度讲确实如此。不过呢，tmux 对于用户的最大价值并不在于终端复用，而在于登录会话保持能力。</div>
					<div class="lang-en2">The name Easytmux implies that, it make using <a href="https://github.com/tmux/tmux" target="_blank">tmux</a> easy. Tmux calls himself a terminal multiplexer. That is correct from technical perspective. But, tmux's greatest value to users does not lie in its multiplexer feature, but login session preserving ability.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">在 GUI 桌面的时代，让终端能够复用已经不是用户的需求痛点了，因为用户这端多开几个终端模拟程序(PuTTY, Xterm 之类)就能够达到复用功能。痛点在于默认的 Linux 终端登录无法在网络状况异常时继续保持会话，意思是，如果远程登录 Linux 主机后 TCP 连接异常断开，那么基于该连接的整个会话将被终结，会话中的所有进程都会被杀死（这是普遍现象）。想象一下，倘若你登录后启动一个需要一小时才能完成的源码编译动作，而中途你的客户机突然断线、睡眠、或是不小心关闭了终端窗口，那么，你在服务端的编译动作就会异常停止，多么让人沮丧。反观 Windows 的远程桌面登录就很体贴。不管客户机何时断线，客户机重连上来后，都能够自动接回原先的会话，原先的桌面状态全部都在。
					</div>
					<div class="lang-en2">In GUI desktop era, multiplexing a terminal has never been a pain to the user, because user can launch multiple terminal programs connecting to the same server to achieve multiplexing. The pain in the throat is that Linux default login server will not preserve user's login session when the underlying network connection is broken. In other word, if user's TCP connection is lost, then the whole session is destroy by the server, all processes in that session get killed(the most commonly case). Imagine, in case you have started a compiler command that would finish its work in one hour, and halfway your client machine inadvertently loses network connection, sleeps, or has the terminal window closed, then, your server-side compiling action will almost be certain to cease. How frustrating! In contrast, let's see how Windows remote desktop service reacts to this. No matter how the network connection gets lost, Windows server preserves user's login-session; when the user connects again, the server side automatically re-attach the new connection to the existing user session, and user feels like he has never experienced any network problem. Cheers! 
					</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">如果 Linux 服务器的默认登录行为也像 Windows 那样该多好。Easytmux 恰恰就是为了这个目的而开发的，甚至体验比 Windows 还要好。Easytmux 依赖 tmux 实现核心功能（即会话保持），它在 tmux 的外围巧妙地加了一些脚本封装，来达成自动会话恢复的体验。</div>
					<div class="lang-en2">If only Linux login server could act as that of Windows! Well, Easytmux is right for that, even better than Windows way. Easytmux relies on tmux to do the core work(session preserving), and with some peripheral scripts, it achieves automatic session restore.</div>
				</div>
				<div class="duallang">
					<div class="lang-cn2">如何部署 Easytmux 呢？容易，三步即可：
						<ol>
							<li>在 Linux server 上安装 tmux 软件包。</li>
							<li>将 Easytmux 脚本拷贝到服务端自己能够访问的任意目录中，比如拷贝到 <tt> ~/qlbox/bash/</tt> .</li>
							<li>在 <tt>~/.bashrc</tt> 中加入 Easytmux 启动脚本，比如 <tt>source ~/qlbox/bash/bash.rc.qlbox</tt> .</li>
						</ol>
					</div>
					<div class="lang-en2">How to deploy Easytmux ? Easy, three steps:
						<ol>
							<li>Install tmux package on your Linux server.</li>
							<li>Copy Easytmux scripts onto server-side directory, such as <tt> ~/qlbox/bash/</tt> .</li>
							<li>In <tt>~/.bashrc</tt> , add Easytmux startup script, e.g., <tt>source ~/qlbox/bash/bash.rc.qlbox</tt> .</li>
						</ol>
					</div>
				</div>
				<div class="imagerow imagerow--textandimage">
<!-- image-text col1: -->
					<div>
						<div class="duallang">
							<div class="lang-cn2">首次登录，用户会看到友善的提示，“用完后不要敲 exit 结束会话，而是直接关闭终端窗口，下次登录会自动恢复会话。” <br><br>
							</div>
							<div class="lang-en2">First-time login, user will see a friendly prompt: "No need to type 'exit' when you finish, just close your terminal window." <br><br>
							</div>
						</div>
						<img src="res/easytmux-login1.png" alt="First-time login with Easytmux." />
					</div>
<!-- image-text col2: -->
					<div>
						<div class="duallang">
							<div class="lang-cn2">关闭终端窗口后再次登录，Easytmux 将提示你在服务端已经有一个会话，询问是连接到原先的会话还是坚持创建一个新会话。这个行为比 Windows server 灵活，Windows server 此时不会给你选择。
							</div>
							<div class="lang-en2">Close your terminal window and connect again, now Easytmux will offer you two choices, attach to original session or create a brand new session. Easytmux does better than Windows server here, because Windows server does not give you the choice here.
							</div>
							
						</div>
						<img src="res/easytmux-login2.png" alt="Re-login after connection lost." />
					</div>
				</div>
			</div>
			<div class="careertable__skill">
				<ul>
					<li>Linux</li>
				</ul>
			</div>
		</div>
	
	</div> <!-- careertable, life as a programmer -->


	<!-- ========== h1title ========== -->
	<h1 class="h1title">
		<div class="lang-cn0">产品故事</div>
		<div class="lang-en0">Product Story</div>
		<div class="stripe"></div>
	</h1>

	<div class="h1intro">
		<div class="duallang">
			<div class="lang-cn2">为了让我的信息能够具体一些，我觉得我应该详细地讲解一下我做过的工作。</div>
			<div class="lang-en2">To make my information concrete, I think I have to provide some details about what I have done.</div>
		</div>
		
	</div>
	
	<h2 class="h2title">
		<div class="lang-cn0">UFCOM 虚拟串口驱动程序</div>
		<div class="lang-en0">The UFCOM virtual COM port driver</div>
		<div class="stripe"></div>
	</h2>

	<div class="lv2content">
		<div class="imgbox-float-right">
			<img border="0" src="res/ufcom-1.7.12.png" width="320" />
			<div class="imgbox-float-right__foottext">UFCOM main UI with Device Manager.</div>
		</div>
		<div class="duallang">
			<div class="lang-cn2">UFCOM 是我到目前为止最重要的软件作品。它也是我完成过的最具挑战性的任务。非常幸运的是，我没有让自己失望。在解决了几百个问题以及发布二十多个版本后，它已经工作得非常漂亮了，远远超越该项目启动时我对它的期望。一句话，UFCOM 是非常成功的作品。
			</div>
			<div class="lang-en2">UFCOM is the most important software of mine up to now, and it is the most challenging work I have done. Luckily, I'm not disappointed by myself. After solving hundreds of issues and releasing 20+ versions, it works like a charm, far beyond my initial expectations on project startup. In one word, UFCOM is a great success.
			</div>
		</div>
		<div class="duallang">
			<div class="lang-cn2">UFCOM 向新大陆条码扫描枪的用户免费提供，目前（2019 六月）在 <a href="http://down.nlscan.com:82/Release/UFCOM/" target="_blank">down.nlscan.com</a> 可以被下载到。目前的最新版本是 1.7.12 。你也可以先看看它的用户指南来了解一下它有哪些特色功能（<a href="res/ufcom-userguide-1.7.12-chs.pdf" target="_blank">中文版用户指南, PDF 格式</a>）。</div>
			<div class="lang-en2">UFCOM is provided to Newland barcode scanner users for free, and is available at <a href="http://down.nlscan.com:82/Release/UFCOM/" target="_blank">down.nlscan.com</a> as of June 2019. Current latest version is 1.7.12 . You can also peek into its features by reviewing its user guide (<a href="res/ufcom-userguide-1.7.12-eng.pdf" target="_blank">English-version user guide in PDF format</a>).</div>
		</div>

		<div class="duallang ques">
			<div class="lang-cn2">UFCOM 是个什么样的软件？</div>
			<div class="lang-en2">What kind of software is UFCOM?</div>
		</div>
		<div class="duallang ans">
			<div class="lang-cn2">我在用户指南里是这么写的：
			<quote>
			UFCOM(USB Flexible COM Port 的缩写) 是由新大陆自动识别公司开发的全新的虚拟串口驱动程序，2017 年起向我们的客户提供，它配合虚拟串口模式的 USB 扫描枪使用，提供和 USB 扫描枪之间的双向通信功能。UFCOM 可运行于 Windows XP ~ Windows 10 x86 & x64 所有版本，也包括同时代的各版本 Windows Server 。

UFCOM 提供的功能和 Windows 系统自带的通用虚拟串口驱动 usbser.sys 类似，可完全替代 usbser.sys ，不但修正了 usbser.sys 的很多糟糕行为，还提供了更强大的功能。
			</quote>
			</div>
			<div class="lang-en2">I state it in the User Guide:
				<quote>
				UFCOM(abbreviation of USB Flexible COM Port) is a brand new Virtual COM Port driver developed by Newland Auto-ID. We provide this driver to our customer since year 2017. This driver works with our barcode scanner hardware; it enables bidirectional communication between your Windows applications and our scanners. UFCOM works on Windows XP ~ Windows 10, x86 & x64 platforms, and their Server counterparts.

	UFCOM provides similar functionality as that of Windows stock usbser.sys and acts as a replacement for usbser.sys. UFCOM not only fixes many ugly behaviors of usbser.sys, but also is much more feature-rich.
				</quote>
			</div>
		</div>

		<div class="duallang ques">
			<div class="lang-cn2">UFCOM 的哪些工作是由我完成的？</div>
			<div class="lang-en2">Which parts of UFCOM is accomplished by me?</div>
		</div>
		<div class="duallang ans">
			<div class="lang-cn2">99% 的工作由我完成。包括以下部分：可行性调研，功能设计，用户界面设计，具体编码，bug 修正，自动构建系统，调试与诊断措施，自测程序，测试指南，用户指南，安装包制作。
			</div>
			<div class="lang-en2">99 percent of it. Including: Feasibility investigation, feature design, user interface design, actual coding, bug fixing, build system, debugging and diagnosing facility, self-testing programs, testing guide, user guide, and installer making.
			</div>
		</div>

		<div class="duallang ques">
			<div class="lang-cn2">我们为什么需要开发 UFCOM 呢？</div>
			<div class="lang-en2">Why do we need UFCOM?</div>
		</div>
		<div class="duallang ans">
			<div class="lang-cn2">简言之，没有 UFCOM 这样的驱动程序的话，在 Windows 10 之前的 PC 上使用虚拟串口方式跟 USB 设备进行通信，犹如鱼鲠在喉。</div>
			<div class="lang-en2">Briefly speaking, without driver software like UFCOM, using virtual COM port interface to communicate with a USB device is a real pain in the neck, unless you upgrade to Windows 10.</div>
		</div>
		<div class="duallang ans">
			<div class="lang-cn2">从 Windows XP 起，微软提供了一个叫 usbser.sys 的驱动程序文件，用于实现虚拟串口功能。USB 外设厂商只需自行准备一个 .inf 文件即可让 Windows 生成虚拟串口。然而不幸的是，这个老式的 usbser.sys 是如此的 buggy 以至于它只能被当作一个玩具来使用。最糟糕的一个行为是：应用程序未关闭串口句柄的情况下，用户拔除 USB 硬件，虚拟串口设备对象将陷入瘫痪，重新插入 USB 硬件也难以恢复。此问题一直到 Windows 8.1 都没有改进。</div>
			<div class="lang-en2">Since Windows XP, Microsoft has bundled a driver file named usbser.sys with Windows OS, which is to provide virtual COM port functionality for USB devices. But unfortunately, this stale driver is so buggy that you can only use it as a toy, that is, not suitable for production use. The most worse behavior is: If the user unplug the USB hardware device without first closing application layer COM port handle, the driver object will fail, and replugging the USB device will not guarantee recovery. Even Windows 8.1 has not made any improvement to this.</div>
		</div>
		<div class="duallang ans">
			<div class="lang-cn2">因此，USB 硬件厂商（比如 USB 条码扫描枪厂商）必须提供专门开发的虚拟串口驱动程序来解决那些 bug。知名国际条码设备厂商其实都已经这么做了（比如 Symbol Technologies, Honeywell AIDC, Datalogic）。然而新大陆在 Windows 驱动程序方面几乎没有技术积累，随着客户逐年增多，这就成了个大问题。公司一直希望有人能够承担这项任务，也请人做了一些尝试，但都没有大的进展。时间到了 2015 年，我维护的 PT-850 系列产品接近生命周期尾声了，因此我能够腾出时间来尝试啃动这块硬骨头。
			</div>
			<div class="lang-en2">Therefore, USB hardware(e.g., USB barcode scanner) vendors has to provide their own non-buggy drivers. Well known world-wide barcode device vendors have done this already, such as Symbol Technologies, Honeywell AIDC, and Datalogic. But Newland has little tech knowledge in Windows driver development, and this becomes a big problem as she gains more and more customers country-wide and world-wide. Of course, the company has hoped someone can assume this driver development work, and someone has tried, but no much progress. The time comes to 2015, and the PT-850 series I have been maintaining is close to its end of life, so I finally have time to dig into this tough problem and try to push it forward.
			</div>
		</div>

		<div class="duallang ques">
			<div class="lang-cn2">我如何取得进展？</div>
			<div class="lang-en2">How do I make progress?</div>
		</div>
		<div class="ans">
			<div class="duallang">
				<div class="lang-cn2">这项工作需要来自三个领域的知识。一，理解 USB 协议是如何工作的；二，Windows 内核架构以及调试内核代码的方法；三，软件工程方法。看看到 2015 年的时候我已经有了哪些积累了。</div>
				<div class="lang-en2">It needs knowledge from 3 realms. (1) Understand how USB protocol works; (2) Windows kernel architecture and kernel code debugging technique; (3) software engineering methodology. Let's see what I have by year 2015.</div>
			</div>
			<ul>
				<li>
					<div class="duallang">
						<div class="lang-cn2">USB 协议: 50% 就绪。对于 USB 我已经有相当程度的了解了，因为在过去的一年中，我对 PT-850 的设备端 USB 代码进行了彻底重写。在那之前，PT-850 有一份现成的 USB 代码，那是我的几位前同事在八年之前开发的，能工作，但功能很少而且比较脆弱——它们仅仅是将芯片提供商给的样板代码做了一些修补而已。但我的做事风格不同，我会尽力弄懂代码背后的每一项概念。因此，我在翻新 USB 代码的过程中对 USB 协议进行了较为深入的研究。值得一提的一个工具是 USB 协议分析器，称作 <a href="https://www.totalphase.com/products/beagle-usb480/" target="_blank">Beagle USB 480</a>. 这个小玩意儿能捕捉 USB 物理线路上的数据包，向我们展示真实世界中 USB 协议的工作过程。对于 USB 开发来说，它是不可或缺的工具。没有它，我很难取得进展，换言之，我无法仅仅通过阅读 USB 协议规范文本来理解 USB。</div>
						<div class="lang-en2">USB protocol: 50% ready. I have known USB quite a bit, because in the past year I did a complete rewrite of PT-850's USB device-side code. Before that, PT-850's had its own USB code, developed by some colleagues 8 years ago, workable, but feature poor and somewhat fragile -- they just copied the boilerplate code from USB chip vendor and did some patches to make it work. But my way is different, I tried to comprehend each bit of concept behind my code. So, during my overhaul, I studied USB protocol to quite some extent. One tool worth mentioning is the USB protocol analyzer, called <a href="https://www.totalphase.com/products/beagle-usb480/" target="_blank">Beagle USB 480</a>. This small gadget captures USB packets from physical lines and show me how USB protocol works in real world. It is indispensable for USB software development. Without it, I can hardly make any progress. In other word, I can't get to know USB just by reading the specification text.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">Windows 内核: 10% 就绪。我有过几年的 Windows C++ 应用程序开发经验，这肯定有帮助，但进入内核领域更像是需要学习一个全新领域的知识。
						</div>
						<div class="lang-en2">Windows kernel: 10% ready. I have some years of Windows application layer development with C++, and sure it helps, but entering kernel layer is more like entering a whole new realm. 
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">软件工程方法: 80% 就绪。我的软件工程思想都是从实践中总结而来的，毕竟我已经有了 12 年的软件开发经验了。我需要保证开发过程向正确的方向行进、少走弯路，需要保证在软件结构变得复杂之后依旧能够不断地改进、且保持高质量，需要让软件容易被测试、让潜藏的缺陷能够尽早暴露出来而非掩藏得更深，需要有一套自动构建设施来让版本发布很便捷且不会轻易引入人工错误。总体思想有了就成功了一半，针对具体问题的实现方法可以留待具体问题出现时再解决。
						</div>
						<div class="lang-en2">Methodology: 80% ready. My software engineering methodology comes from my own practice over the past 12 years. I need to: ensure the development always heads for the right direction, less detour; ensure there is always room for improvement, no compromise to quality, even after the software becomes complex; ensure the software can be easily tested, to make potential bugs stand out instead of hiding them deeper; ensure an automated build facility works so that version releasing is convenient without manual error slipping in. Holding correct general idea is half the success, specific issues should always have a way out.
						</div>
					</div>
				</li>
			</ul>
			<div class="duallang">
				<div class="lang-cn2">既然最大的一块空缺在 Windows 内核上，我需要找到这方面的学习材料。事实上，对于新领域的学习，我非常依赖书籍。一本好的明确主题的书籍，能够让我对那个主题有系统性的了解。我很奇怪我的同事很少像我这样看书，他们似乎总是通过搜索网上零碎的文章来学习。网上文章的缺点在于，它们通常篇幅有限，很难呈现一个知识体系的全貌，对于所陈述的内容常常缺乏足够的背景上下文铺垫。从 Internet 上找来的零零星星的资料，也许有助于解决一些很具体的问题，或是得到一些灵感，但对于建立起一个新领域的系统性全局观就很难有帮助了。也许这能够解释为什么公司多年来在 Windows 驱动程序改进上几乎没有进展了。</div>
				<div class="lang-en2">Since the biggest lack is about Windows kernel, I need to find learning material in this realm. Actually, when it comes to new knowledge area, I rely heavily on books. A book with clear topic can introduce me to that topic systematically. I'm curious about my colleagues' despising the usefulness of a computer book; they seem to have a tendency of finding Internet articles as learning source. The downside of Internet articles is, they are mostly limited by their length, not "lengthy" enough to present a full view of a realm, and in many cases in short of background and context introduction. Grabbing odds and ends from the Internet may be helpful to solve some concrete issues or to get some enlightenment, but it helps little to achieve a solid systematic insight of a new realm. Maybe that explains why the company made little progress in Windows driver for so many years.</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">我找到了四本和 Windows 驱动开发有关的书籍：</div>
				<div class="lang-en2">I find three useful books that is highly related to Windows driver developing:</div>
			</div>
			<ul>
				<li>#1 <a href="https://www.microsoftpressstore.com/store/developing-drivers-with-the-windows-driver-foundation-9780735623743" target="_blank">Developing Drivers with the Windows Driver Foundation</a> -- Microsoft Press 2007</li>
				<li>#2 <a href="https://www.amazon.com/Programming-Microsoft-Windows-Developer-Reference/dp/0735618038" target="_blank">Programming the Microsoft Windows Driver Model (2nd Edition)</a> -- Microsoft Press 2002</li> 
				<li>#3 <a href="https://www.microsoftpressstore.com/store/inside-windows-debugging-9780735662780" target="_blank">Inside Windows Debugging</a> -- Microsoft Press 2012</li>
				<li>#4 <a href="https://www.microsoftpressstore.com/store/windows-internals-part-1-9780735656567" target="_blank">Windows Internals, 6th-edition</a> -- Microsoft Press 2012</li>
			</ul>
			<div class="duallang">
				<div class="lang-cn2">头两本是有关内核 API 的，第三本有关调试工具，第四本是系统全局观。这四本书让我看到了成功的曙光。因此，我的工作分成了五个阶段来展开。以下标注的各阶段时长有部分重叠，而不是界限分明的先后关系。
				</div>
				<div class="lang-en2">The first two are about Kernel API, the third about debugging tools, the fourth about system architecture. These three books shed light on my way to success. So, I carried out my work in four stages. The time ranges I mark below is of coarse estimation, they overlaps somewhat, not strictly one after another.
				</div>
			</div>
			<ul>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第一阶段，六个月。主要是信息收集和调查工作，包括：进一步了解 Visual Studio 和 WinDBG 等开发工具的功能，比如远程调试，尝试 symbol server 和 source server，进一步了解 Windows 操作系统提供的功能，设定 UFCOM 的功能目标。#3 与 #4 两本书给了很大帮助。</div>
						<div class="lang-en2">Stage One, six months. Most time is spent on information gathering and investigating, including: get to know deeper of tools like Visual Studio and WinDBG, such as remote debugging, try symbol server and source server, dig deeper to know the potential of Windows OS, so to establish UFCOM's feature goals. Book #3 and #4 helps a lot.</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第二阶段，五个月。学习内核 API。方法很直白，详读 #2、然后 #1 两本书，同时尝试它们给出的例子程序。</div>
						<div class="lang-en2">Stage Two, five months. Learn the kernel API. Peruse book #2 then #1, at the same time try the sample programs provided.</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第三阶段，三个月。逐行研究 Windows 7 Driver Kit(WDK7) 给出的 Toaster 系列代码，结合书本 #2 和 #1 来理解它们，并且实地编译运行它们。 Toaster 示例代码非常重要，微软借此示例演示了如何给一份骨架驱动程序一步一步地添加功能，最后形成一个完整的软件包。但为什么用 Windows 7 版本的 WDK 呢？因为我发现它是最后一个支持 Windows XP 的版本。我们的客户中很多人还在使用经典的 Windows XP, 我不想落下他们。
						</div>
						<div class="lang-en2">Stage Three, three months. Scrutinize the Toaster sample code provided by Windows 7 Driver Kit(WDK7). The Toaster sample code series is of utter importance for driver learning. Microsoft demonstrates with it the whole driver developing lifecycle, starting from a piece of skeleton code, adding features step by step, then finally a full blown driver package. But why I choose WDK7? Because it is the final version to support Windows XP, the ever classic Windows OS that many our customers are staying with, and I don't want to leave them alone.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第四阶段，三个月。开始真正的 UFCOM 编码，直至其达成预期的功能。你知道的，在前面长达一年多的准备时间中，我其实一直在构想 UFCOM 应该达成的功能，我不甘心只是做已有同类软件的模仿者，我从 UFCOM 用户的角度来考察我的作品将呈现的模样，确实发现有很多潜在的需求是已有的同类软件都没有做到的，因此我的软件可以很多方面做出突破。真正开始编码那一刻，我已经确认了我至少能够做到下面这几条独创功能：(1) 动态修改设备管理器中的设备显示名称、以反映设备的当前状态；(2) 通过设定 VCOM Lifemode ，用户可以控制扫描枪被拔除后，VCOM 设备是否继续存在；(3) 通过设定 Bindmode，用户可以指定不同型号、不同序列号的扫描枪是关联到同一个串口号还是不同的串口号。
						</div>
						<div class="lang-en2">Stage Four, three months. Start actual UFCOM coding, until it reaches the functionality I have longed for. You know, I have always been conceiving the feature set of UFCOM before my coding actually starts because I'm not gratified to be a follower of existing counterpart software. I try to consider my software from a user's perspective, and find that may potential requirements have not been implemented by any of those existing software, so I can make many breakthroughs. From the moment I start my first code line for UFCOM, I have confirmed to be capable of adding these creativity features to UFCOM: (1) Dynamic device display name in Device Manager so that user know the device state intuitively. (2) By choosing a VCOM Lifemode, user can control whether the VCOM is still present after the scanner is unplugged from your system. (3) By choosing a Bindmode, user can decide whether VCOM port number association behavior is determined by scanner device-type or by device-serial-number.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">能进行到这一步，我已经说服自己继续推进该项目的绝大部分不确定性已经消除了，剩下的只是具体的细节问题了，因此我可以放心地开始真正的编码了，而不用担心编码到一半遭遇重大障碍而功亏一篑。最终证明，老天没有辜负我的期望，2017 十二月我在公司内发布第一个内测版本(1.0.3)时，预期功能顺利达成，而且后续所有版本也都是稳步改进，虽然编码过程虽然有一些波折，但没有出现重大的 bug 和回退，小的 bug 都能很快定位到原因并且在几天到几个星期内就能解决。
						</div>
						<div class="lang-en2">At this point, I have convinced myself that most uncertainty factors regarding this project have been dispelled, and I can peacefully start actual coding, without worrying about running into big obstacles and fail myself. It proves that I've made it well. I makes my first release company-wide in Dec 2017, and subsequent versions improve steadily. Despite some ripples on code refactoring, no prominent bugs ever arose, and small bugs are identified quickly, solving in several days or a few weeks.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第五阶段，一年。发布首个版本是里程碑，但一款软件只有不断迭代改进才会变得成熟。接下来的时间,我可以比较从容地对 UFCOM 进行外围改进了，让它变得更加友好易用。当然，用户反馈也是 UFCOM 改进的动力。主要改进有以下方面：
						</div>
						<div class="lang-en2">Stage Five, one year. Making first release is the milestone, but a piece of software matures only by continuous iteration. During the time that follows, I can make peripheral improvements to UFCOM to make it more friendly. Of course user feedback helps push it forward. I improve it in many aspects. 
						</div>
					</div>
					<ol>
						<li>
							<div class="duallang">
								<div class="lang-cn2">日志功能。用户可以轻松地让驱动程序生成文本格式的日志。遇到故障时，用户将日志文件发送给开发者以便远程诊断问题。
								</div>
								<div class="lang-en2">Logging functionality. User can easily tell the driver to generate text-based logging information, and in case of problem, user can send the log to developer for diagnosing.</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">Msi 格式的安装包。用户仅需双击 msi 文件，一路点击“下一步”即可安装完成。也可以用命令行启动静默安装方便用户进行脚本集成。
								</div>
								<div class="lang-en2">Installer in msi format. User just need to double click the msi file, clicking "Next" several times to accomplish installation. Or, user can use command line based silent installation, so to integrate it into his own script.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">全部编译过程的自动化。意即，一条启动命令即可编译/构建所有代码、生成最终的 msi 安装包。
								</div>
								<div class="lang-en2">Make the whole compiling/building process automatic. Yes, one startup command line builds everything, resulting in a final msi package.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">将 UFCOM 提交 WHQL 认证，顺利通过。在使用认证工具测试 UFCOM 的期间，发现并修复了一些隐蔽的 bug。</div>
								<div class="lang-en2">Submit UFCOM to WHQL certification, pass with success. During the course of testing with certification tool, some subtle bugs are identified and get fixed.</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">自测与自我诊断小工具。我自己可以用它们来测试 UFCOM 的 API 行为，以及测试传输速度。这些工具也大方地提供给用户。
								</div>
								<div class="lang-en2">Self-testing and verification tools. I myself use them to test UFCOM API conformity, and USB transferring speed. I also generously provide these tools to our users.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">强悍的调试设施。当我需要调试任何一个 UFCOM 版本时，我能够让 WinDBG 或 Visual Studio 当场从 SVN 源码仓库中取出对应 UFCOM 版本的源代码，并开始源码级别的调试，单步执行，观察变量等。这就是我通常能在发现 bug 的当天就定位到故障原因的秘诀。
								</div>
								<div class="lang-en2">Powerful debugging facility. When I wants to debug UFCOM's code, I can tell WinDBG or Visual Studio to grab source code of the corresponding version and start source-level debugging on it, step execution, view variable content etc. This is why I can usually pinpoint the error source the very day a bug is identified.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">许许多多的小功能和 bug 修复...</div>
								<div class="lang-en2">Many many small features and bug fixes...</div>
							</div>
						</li>
					</ol>
				</li>
			</ul>
		</div>
		<div class="duallang ques">
			<div class="lang-cn2">UFCOM 取得成功的那些关键因素有哪些？</div>
			<div class="lang-en2">What are the keys to UFCOM's success？</div>
		</div>
		<div class="ans">
			<div class="duallang">
				<div class="lang-cn2">我将其总结为以下几个原因：</div>
				<div class="lang-en2">I summarize it as following reasons:</div>
			</div>
			<ol>
				<li>
					<div class="duallang">
						<div class="lang-cn2">清醒地认识我所处的软件环境。驱动程序所处的环境就是它所在的操作系统，而操作系统完全是人为设计的产物。对于人为设计的系统，我认为探明其中各个环节的因果关系非常重要。我得分辨出这个系统中哪些要素是完全人为的设计，哪些要素是从预先设计的前提中推导出的必然结果。分清了各个要素的这两项性质，整个系统的结构也就清晰了。书和文档中有时候并不会很明确地向我传达这些因果关系，很多时候我得自行体会和验证。洞察了因果关系之后，我可以对很多未明说的问题作出合理的推测，这能够进一步加深我对系统的认知。
						</div>
						<div class="lang-en2">Get to know my software environment with insight. A driver's environment is the operating system, and the operating system is totally a human artifact. For a human artifact system, I think it is critical to figure out causal relationships of the elements within. I have to identify which elements are pure human design, and which are the results of predefined factors. With these in mind, the overall system structure will become clear. Book and docs may not explicitly state every underlying relationships, so I have to grok and verify them. With causal relationships in mind, I will be able to make many rational conjectures, and I help me understand the system deeper.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">耐心，不犯懒，多花时间来验证书和文档中告知的信息，让每一个知识点的推进都很牢靠。
						</div>
						<div class="lang-en2">Be patient, and don't be lazy. Spend time to verify what is stated in books and docs, in case of doubt. Every step upward should be solid.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">注重能够提高效率的工具。有三个非常典型的例子：
						</div>
						<div class="lang-en2">Consider productivity tools seriously. I have three prominent examples:
						</div>
					</div>
					<ul>
						<li>
							<div class="duallang">
								<div class="lang-cn2">一，我的实验与开发工作 99% 是在虚拟机中进行的，虚拟机软件带来效率提升是极其明显的，调试代码的过程常常会遭遇死机，那就得重启 Windows，真机重启至少需要三分钟，而且重启后还无法保证让系统回到上一次开始调试时的同样状态（文件和注册表内容可能因为死机而遭到了破坏）；虚拟机只需要三十秒即可恢复，而且能保证回到初始状态。这两者的效率差别，何止是十倍。
								</div>
								<div class="lang-en2">First, I carry out my experiments and developing work on virtual machine(VM) 99% of the time. The productivity boost by VMs is dramatic. When debugging kernel code, system crashes are common, then I have to reboot the debuggee machine, and it will cost at least three minutes for a physical machine. What's worse, a rebooted machine is not guaranteed to have its healthy state restored(because file and registry content may have been damaged due to the crash). For a VM, 30 seconds is enough for state restoration, and it guarantees that the machine state is definitely intact. What a ten times life saver.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">二，我使用一个叫 VisualDDK 的软件来作为调试工具（它表现为 Visual Studio 2010 中深度集成的一个插件），不过分地说，它的调试功能比微软 Visual Studio 2015 自带的内核调试功能好上好几倍，我甚至觉得 Visual Studio 2012 起引入的内核调试功能是从 VisualDDK 那里模仿而来的，但却依旧赶不上。比如，VisualDDK 能够显示一个内核句柄背后的对象内容，然而 VS2015 却只能显示句柄值。
								</div>
								<div class="lang-en2">Second, I use a tool called VisualDDK at debugger side. It is a deeply integrated Add-on for Visual Studio 2010. Without any exaggeration, VisualDDK's kernel code debugging feature is far better than that of Visual Studio 2015. I even have the feeling that the kernel debugging feature introduced since Visual Studio 2012 is an imitator of VisualDDK but never catch up. For example, VisualDDK show the object content behind a kernel handle, while  VS2015 shows only handle value.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">三，真正开始编码前，我花费了很大精力来建立 <a href="https://docs.microsoft.com/en-us/windows/desktop/Debug/symbol-servers-and-symbol-stores" target="_blank">symbol server</a> 和 source server 调试手段，它们的作用是让我能够取得任意版本程序崩溃现场的源代码、快速找到崩溃原因。所谓养兵千日用兵一时，在整个 UFCOM 的改进过程中，这套调试手段真正派上用场的次数也不过三次，但我觉得我已经赚到了。如果没有这套手段，我将在真实的崩溃面前将陷入黑暗和无助。既然微软已经如此先见之明地提供了定位故障源码的基础设施，我真的没有理由不去利用它。
								</div>
								<div class="lang-en2">
								Third, I made a lot of effort to set up <a href="https://docs.microsoft.com/en-us/windows/desktop/Debug/symbol-servers-and-symbol-stores" target="_blank">"symbol server"</a> and "source server" as my debugging facility. They enable me to fetch correct source code of the matching version for my driver on situation it fails or crashes, then I can pinpoint the error source line. During the whole UFCOM improving period, this facility really comes in handy. Although used only three times, it is really worth the effort. Were I not having this facility, I would have been trapped in darkness and despair in front of a real-world crash. Since Microsoft has envisioned the necessity of this debugging facility, why not set it up?
								</div>
							</div>
						</li>
					</ul>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">不断地为 UFCOM 构思新的功能，在试图实现新功能的过程中，常常能够发现先前设计的不足、或是先前实现方法的不足。编写软件最怕的就是“盲知”的状态，在没有收到用户反馈前根本意识不到自己的软件有什么毛病。仅仅依赖用户的反馈来做改进的一个巨大局限是，你很难得到深层问题的反馈。普通用户不会超出手中软件的功能边界来给你提出反馈，他们的普遍行为是撞到 bug 之后才提出反馈，甚至不会提出反馈——如果 bug 比较轻微且有变通方法的话。正是抱着这种理念，在第一个内测版本发布后，我就一直主动地给 UFCOM 添加新功能，这种努力的成果也是巨大的，有 80% 的 bug 是被我自己提前发现的，剩余 20% 是我的同事（包括测试部门）发现的，而由最终用户率先报告的几乎没有。
						</div>
						<div class="lang-en2">I constantly conceive new features for UFCOM, and during the course of implementing those new features, I more and more potential design flaws coding defects arise. Blindness is an awful state for a standalone software developer. It means he is totally unaware of the problems inside his software before users give explicit feedback. The big limitation of relying solely from user feedback is, you can hardly get in-depth feedbacks from your user. Average users will not provide feedbacks that is beyond software functionality. Their feedbacks mostly target only perceptible bugs, or even no feedback -- if the bug is minor and workaround is available. With this notion in mind, I actively add new features to UFCOM, and it pays back. Nearly 80% of the bugs are identified by myself; only 20% are identified by my colleagues(including those from QA department). Bugs initially reported by our end users? Almost none.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">最后不得不说，关键时刻需要一点点好运气帮忙。我曾经在被调试虚拟机中碰到一个神秘的崩溃现象，在拔除 USB 设备时触发，不过另一个隐蔽的触发条件似乎是我的宿主机运行变得迟缓。你知道的，Windows 机器上同时运行太多的程序太多天就容易出现迟缓现象，或称系统卡顿。我敏感地意识到这可能是一个新 bug，因为之前已知的 bug 都被我干掉了。既然我手头有 VisualDDK 这么强大的调试工具，我肯定要挖一挖它的原因。我试图重现该故障几次后，果然我定位到一处隐秘的代码缺陷，这种隐蔽问题在我看过的书和文档中似乎都没有提及。既然定位到原因，就趁机将其修正。现在不修的话，可能再难有机会碰到今天这样能够触发它的环境了。我在日记中这样写道：“2017-06-23: 确认一个事实, WdfRequestSend 指定的 Completion-routine 完全有可能在目标设备 ReleaseHardware 之后才被回调，虽然这很罕见。”</div>
						<div class="lang-en2">Finally, I admit fortune helps in some critical moments. I once had a mysterious crash on my debuggee VM, when my host Windows runs a bit sluggish. You know, running too many background programs on Windows for too many days can cause sluggish indefinitely. I sensitively deemed it a potential new bug in my program(before I deemed it a Microsoft bug). Since I have such powerful debugging tool with VisualDDK, why not dig it in? I reproduced the symptom several times and found it a subtle coding flaw, that is not clearly mentioned in any books and docs I have read. Well, since it arose with luck in front of me, I fixed it with confidence. I must do it right now, because the luck of have such reproducing environment may not easily come again. I recorded this issue in my diary as: "2017-06-23: Confirmed a fact: Will WdfRequestSend assigned Completion-routine be called *AFTER* the target device's ReleaseHardware has been executed? YES, utterly possible, although VERY RARE".
						</div>
					</div>
				</li>
			</ol>
		</div>
	
	</div>

	<h2 class="h2title">
		<div class="lang-cn0">PT850 和它的配套软件</div>
		<div class="lang-en0">PT850 and its related software</div>
		<div class="stripe"></div>
	</h2>

	<div class="lv2content">
		<div class="duallang">
			<div class="imgbox-float-right">
				<img border="0" src="res/pt850-white.jpg" width="240"/>
				<div class="imgbox-float-right__foottext">Newland PT850 in cradle.</div>
			</div>
			<div class="lang-cn2">这款被命名为 PT-850 的条码采集器，是我头十年的工作生涯中投入时间最多的项目。不可否认，这款采集器是团队协作的成果，它最终也被证明是一款非常受欢迎的产品，即使在面世十年后仍然有很大量的销售。从 2008 年以来，大多数项目组成员将工作重点转移到新产品开发上去了，然后我成为了这款产品软件系统的主要维护者。我认为维护这款老产品是有意义的，因为一方面我知道它还有太多需要改进的地方和需要解决的问题，如果不继续改进，我内心觉得对不起花钱购买了我们产品的客户，另一方面，我希望把一件事情做得完美，至少在我能力所及的范围内应该如此。
			</div>
			<div class="lang-en2">The portable barcode data collector with model name PT850 is the one around which I invested most of effort during the first ten years of my career. Sure, it is the achievement of a whole team, and proves to be a popular product even after 10 years of its debut. Since the year 2008, most team members of this product turn their focus onto new product lines, and I became the primary software maintainer of this product series. I have always thought it meaningful to maintain this somewhat "unfashionable" product because of two reasons. First, I knew that it has too many issues to solve and too much potential to get improved. If I didn't make that way, I would feel guilty of leaving paying users with unfriendly or even buggy software. Second, I hope to make things perfect, at least try to achieve perfection in my scope.
			</div>
		</div>

		<div class="duallang">
			<div class="lang-cn2">我觉得有必要对 PT-850 作一个简要介绍，以便我的陈述显得比较具体。</div>
			<div class="lang-en2">I think I should present a brief introduction to this PT-850, so that my words here sounds a bit more concrete.</div>
		</div>
		
		<div style="clear:both"></div> <!-- This seems a must. Only adding clearfix inside next <div> tag does not help. -->

		<div class="table_s clearfix"> <!-- PT850 brief table >>> -->
			<div class="table__row">
				<div class="table__cell itemname">
					<div class="duallang">
						<div class="lang-cn2">产品生命周期</div>
						<div class="lang-en2">Product Lifecycle</div>
					</div>
				</div>
				<div class="table__cell itemvalue">
					2003 ~ 2016
				</div>
			</div>
			<div class="table__row">
				<div class="table__cell itemname">
					<div class="duallang">
						<div class="lang-cn2">硬件</div>
						<div class="lang-en2">Hardware</div>
					</div>
				</div>
				<div class="table__cell itemvalue">
					<ul>
						<li>CPU: Cirrus Logic EP7312, ARMv7 instruction set, 74MHz</li>
						<li>RAM: 8M Bytes</li>
						<li>NOR flash(as kernel code storage): 2MB</li>
						<li>NAND flash(as file system storage): 16MB ~ 128MB</li>
						<li>Barcode scanner engine: Symbol SE1200 or SE965</li>
						<li>Display: 160*128 4-level grayscale LCD</li>
						<li>Communication peripherals: RS-232 serial port; USB 1.1 slave side controller by Philips PDIUSBD12</li>
						<li>Wireless communications: GPRS module by SIEMENS MC35/MC35i or SIMCOM SIM900A; 802.11g Wifi with Lantronix WiPort, TCP/IP/MAC protocol integrated </li>
					</ul>
				</div>
			</div>
			<div class="table__row">
				<div class="table__cell itemname">
					<div class="duallang">
						<div class="lang-cn2">软件系统</div>
						<div class="lang-en2">Software system</div>
					</div>
				</div>
				<div class="table__cell itemvalue">
					<ul>
						<li>
							<div class="duallang">
								<div class="lang-cn2">内核: 基于 uC/OS-II 2.5 的实时多任务操作系统，外围设备的驱动程序由团队成员自行编写。我们称 PT-850 的内核为 uBase-III 。PT-850 的内核总共经历了 6 个大版本和 30 多个小版本，这些版本依旧可以从<a href="http://down.nlscan.com:82/Release/uBase/uBase-III-kernel/" target="_blank">此处</a>获取。
								</div>
								<div class="lang-en2">Kernel: RTOS based on uC/OS-II 2.5; peripheral device drivers written by our team members. We call PT-850's kernel uBase-III. PT-850's kernel goes through 6 big versions and over 30 small versions during it life time. These versions can still be found <a href="http://down.nlscan.com:82/Release/uBase/uBase-III-kernel/" target="_blank">here</a>.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">文件系统：<a href="https://github.com/rickyzheng/uffs" target="_blank">UFFS</a> ，由此项目的软件架构师郑功梓开发，这是位博学的项目领导者。</div>
								<div class="lang-en2">File system: <a href="https://github.com/rickyzheng/uffs" target="_blank">UFFS</a>, developed by the very project architect Ricky Zheng, who is a knowledgeable project lead.</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">使用的编译器： ARM SDT 2.50 (1999 年时的版本)。内核和应用程序都使用此版本编译器，内核编译后大小 600KB 左右，应用程序大小 50KB~300KB。</div>
								<div class="lang-en2">Compiler used: ARM SDT 2.50 (since 1999). Both kernel and application use this compiler. The kernel compiled size is around 600KB, and the application varies from 50KB to 300KB.</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">为什么我们在整个产品生命周期中都没有更换新版本的编译器呢？因为[内核中的应用程序装载器代码]是跟[应用程序的二进制代码格式]紧密耦合的。简单地升级内核编译器会导致应用程序装载器无法匹配原先应用程序的二进制接口。开发一个新内核、同时能够兼容过往的应用程序，按理说是最好的做法，但这个任务对我们团队过于艰巨，因此我们止步于此。
								</div>
								<div class="lang-en2">Why don't we upgrade the compiler to newer versions during the whole product life cycle? Because the app-loader inside the kernel code is tightly coupled with user's application binary code. Simply upgrading the kernel compiler can cause binary interface mismatch between the kernel and the application layer. Developing a new kernel with good backward compatibility of old binary code may be the best solution, but it is a tough work for our team, so we stopped there.
								</div>
							</div>
						</li>
					</ul>
				</div>
			</div>
			<div class="table__row">
				<div class="table__cell itemname">
					<div class="duallang">
						<div class="lang-cn2">用户 SDK</div>
						<div class="lang-en2">User SDK</div>
					</div>
				</div>
				<div class="table__cell itemvalue">
					<div class="duallang">
						<div class="lang-cn2">PT-850 的设计初衷就是为了让用户能够自行定制化开发（我们当时的称呼叫“二次开发”）。意思是，由我们提供内核软件（或说操作系统）和 SDK，用户可以自行编写定制化的应用程序来实现他的业务逻辑。当然，在不改动应用程序的情况下，用户可以单独升级内核来解决系统中的 bug 或得到新的功能。
						</div>
						<div class="lang-en2">PT-850 is meant for customized development. That is, we provide kernel software and SDK, and user can program his own application to accomplish his business logic. Of course, by upgrading the kernel alone, user can get system bug fixes and acquire new features.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">这套 SDK 被称作 uTools，它表现为 Visual C++ 6 集成开发环境(IDE)中的一个插件。用户用 Visual C++ 的强大代码编辑器来编辑他的代码，调用 ARM 编译器来生产二进制文件，再将二进制文件烧写到真机的 Flash 中，非常顺畅的工作流程。
						</div>
						<div class="lang-en2">The SDK we provide is called uTools, which is a Visual C++ 6 IDE add-in. User edits his code in Visual C++ 6's great code editor, and compiles his code to ARM executable binary, flashing the binary to PT-850 real device, all from the Visual C++ IDE, a very smooth workflow.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">uTools 的一个特色功能是，用户可以将自己的代码先编译成 Windows 平台上的模拟程序，利用 Visual C++ 强悍的可视化调试器来调试好代码，然后再编译成 ARM 的目标代码。这个功能大大节省了应用程序的开发时间，你想想，编译一个模拟器程序并当场运行，比起下载真实目标代码到 PT-850 上肯定要快捷得多，而且还弥补了真机上无法进行源码级调试的缺陷，另外，用户还可以在手边没有采集器真机的情况下继续开发和调试。
						</div>
						<div class="lang-en2">One prominent feature of uTools is, user can compile his code into Windows simulator programs. With the help of powerful Visual C++ debugger, user debugs his code with thoroughness, then compile to real ARM code. This feature is a great time saver. Think of it, compiling into a simulator program and run it on the spot, is surely much speedier than downloading code to a real PT-850 machine, and it provides a workaround for not being able to do source-level debugging on the real machine. Furthermore, user can go on development without a real device at hand. 
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">能够达成这个功能，是因为我们将 uBase-III 的绝大多数内核 API 都在 Windows 系统上进行了相同功能的实现。项目架构师郑功梓在 2002 年时设计了这个功能，我表示非常的赞赏。下方是真机上和模拟器中运行 Shell 应用程序的画面对比。
						</div>
						<div class="lang-en2">We achieve this by implementing most kernel API on Windows system, with the "same" functionality as real machine. Our architect Ricky Zheng designed this feature back in 2002, and I really appreciate this decision. Below, the Shell application UI seen on real machine, and the simulator program UI as a Windows EXE.
						</div>
					</div>
					<div class="imagerow">
						<div>
							<img src="res/pt850-real-shellui.jpg" width="200px"/>
						</div>
						<div>
							<img src="res/pt850-simulator-shell.png"/>
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">为了支持应用程序的定制化开发，uTools 中提供了各种函数库供用户调用。比如：文件系统 API；线程 API；GUI 图形库（称 UFC）；条码扫描 API；简易的 HTTP 客户端库（称 WebComm）；通过串口或 USB 传输文件的通信库（称 uEasyFile）等等。
						</div>
						<div class="lang-en2">To facilitate customized application development, we provide various user libraries, such as: file system  API; threading API; GUI library(called UFC); barcode scanner API; simple HTTP client library(call WebComm); serial-port or USB based file transfer library(called uEasyFile), and so on.
						</div>
					</div>
				</div>
			</div>
		</div> <!-- PT850 brief table <<< -->

		<div class="duallang">
			<div class="lang-cn2">十多年在一个项目上持续进行改进，我领会到了很多软件开发中极好的原则。
			</div>
			<div class="lang-en2">Improving such a project for 10+ years, I have come to realize quite a lot of great principles in software development.
			</div>
		</div>
		
		<div class="table_s">
			<div class="table__row">
				<div class="table__cell itembrief">
					<div class="duallang">
						<div class="lang-cn2">API 语义稳定的重要性</div>
						<div class="lang-en2">Importance of API semantic stability</div>
					</div>
				</div>
				<div class="table__cell itemdetail">
					<div class="duallang">
						<div class="lang-cn2">我们每天都在使用 API (应用程序编程接口)。操作系统内核跟应用程序代码通过 API 进行互操作。API 是无形的，但它比有形的内核代码和应用层代码重要得多。API 是一组规则或约定，是我们对所需功能的抽象。具体的代码来来去去，浮浮沉沉，但 API 应始终保持稳定。
						</div>
						<div class="lang-en2">We use API(Application Programming Interface) everyday. The OS kernel interoperates with the applications through API. The API is intangible, but is much more important than the tangible kernel code and the application code. The API is a set of rules or agreement, and the abstraction of features we require. Actual code comes and goes, rises and falls, but long live the API should.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">在内核和应用程序都遵循 API 这个中间物的情况下，它们就可以各自独立地进行升级。这实在太有用了，内核代码和应用代码实现了“解耦”的效果，它们可以由完全不同的团队进行开发，多么了不起的效率提升。
						</div>
						<div class="lang-en2">Under the premise that OS kernel and application both conforms to this middleware called API, they can develop separately on their own. The kernel code and the application code get "decoupled"; they can be developed by utterly two different teams. What a efficiency boost.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">在现实中的案例就是：我们升级 Windows 的版本后（比如将 Windows XP 升级到 Windows 7），绝大多数的应用程序是能够继续在 Windows 7 上运行的（只不过在新的 Win7 OS 上某些软件需要重新安装一次）。用户之前在 Windows XP 上的应用软件投资大都能够得到保留。对于 PT-850 也是如此，用户通过自行获取并烧写新的内核版本，就可能够解决很多中途遇到的 bug。这种内核和应用分离的模式，已经越来越广泛地被大量的智能电子设备所采用，典型的如基于 Andriod 或是苹果 iOS 的手机。
						</div>
						<div class="lang-en2">The real world example is: If we upgrade an old Windows version to a new one(e.g., Windows XP to Windows 7), most applications can still run on Windows7, except that, some applications have to go through an "install" procedure on the new Win7 OS. User's most application investment on Windows XP is preserved. It is the same for PT-850; user acquires new kernel version and flash it onto their device, and many bugs get fixed. This OS/app separation mode, has been adopted more and more widely by all kinds of intelligent devices, most typically, mobile phones based on Andriod, or Apple iOS.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">现在，一件重要的事情就是，如何一次性地把 API 设计正确，这项工作甚至可以被称作艺术。我能够感受到，需要多年积累的暗知识以及富有洞察力的经验才能设计好一套经久耐用的 API 。我在改进 PT-850 的内核过程中其实设计了不少的 C/C++ 接口的 API，我能够感受到多年以前的无知，以及自己正在领悟其中的门道。这是个很大的话题，此处不方便展开了……
						</div>
						<div class="lang-en2">Now, one time correctness of API design becomes very important, and even an art. I can feel that quite a lot of dark knowledge and insightful experience are required to design an API with long-term usability and stability. Working with PT-850 for so many years, I have designed quite some APIs for it. I can feel my innocent from many years ago, and I have got many correct ideas along the time. This is a big topic and it may not be suitable to expand it here...
						</div>
					</div>
				</div>
			</div>
			
			<div class="table__row">
				<div class="table__cell itembrief">
					<div class="duallang">
						<div class="lang-cn2">延迟绑定造就动态系统</div>
						<div class="lang-en2">Late binding makes a dynamic system</div>
					</div>
				</div>
				<div class="table__cell itemdetail">
					<div class="duallang">
						<div class="lang-cn2">延迟绑定，意思是，不要将可以参数化的数据写死在代码中，而是要在代码运行的过程中根据外界的输入信息来动态确定。
						</div>
						<div class="lang-en2">By saying late binding, I mean that, do not hardcode parameterizable data, instead, determine those data according to environmental input during code run.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">早些年间，我习惯性地以为，对于 PT-850 这样一个小型的嵌入式系统，内核所看到的设备都是程序员事先确定好的，比如，这个硬件平台中有两个物理串口，一片 NAND Flash 芯片，这说明内核中要创建出三个设备。现在看来，这是相当没有经验的看法。我们需要进一步追问，系统中真的就只能呈现两个串口吗？条码识读器是可以模拟成串口数据源的，基于 USB 的数据通道，也是可以被模拟成一个串口的。Flash 方面的动态性就更强了。一片 Flash 上只能安放一份文件系统吗？当然不是。想想一台 Windows PC 上的硬盘，里头可是有 C: D: E: 这好些个分区的，每个分区都被 Windows 认为是一个设备。这么看起来，单一一个物理设备，在系统中可以呈现出的抽象设备可以是无限多的，不是吗？
						</div>
						<div class="lang-en2">In early years, I naively took it for granted that a small embedded system like PT-850 should have all its "devices" statically considered. For example, this hardware box has two physical serial ports, one NAND Flash chip, which should map to three devices. Now I know I was so inexperienced. We need some challenge. Is the system only limited to two serial ports? The barcode scanner can work like a serial port, because it is actually a data source, right? Does the single Flash chip accommodate only a single file system? Sure not. Think of a Windows PC, a harddisk supports many partitions that is named C: D: E: etc, each of which is considered a device. It looks like a single physical device can support an infinite number of abstract devices.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">一个具有足够动态性的软件系统，你打开它的代码来查看，将发现里头只有针对规则的描述，输入数据与输出数据的格式规则、不同类型数据在不同场景下的意义、不同部件之间交换数据的流程规则等等，而没有具体的数据。具体数据都是代码运行后从代码的外部获取的，比如，存放在硬盘上的数据，来自网络的数据，用户现场输入的数据。拿 PC 上的文件系统举例，当前机器上应该生成多少个文件系统实例，各个实例掌管多大范围的一块磁盘空间，肯定不是写在可执行代码里头的，而是通过代码读取硬盘分区表来确定的。人们需要富有远见地“浪费掉”硬盘上起始处的一点点空间来安放这份硬盘分区表，才能达成这种美妙的延迟绑定，进而得到一个高度动态的系统——非常高明的决定。
						</div>
						<div class="lang-en2">Peeking into a system with sheer power of dynamicity, reveals that it has only rule definitions in its code, rules for input/output data format, rules for interpreting data in different scenarios, rules for exchanging data between various components, but NO actual data.  The actual data, is fed from outside while the system is running, such as, from harddisk, from network, or from a human's onsite input. Take PC's file system for example, how many file system instances should be presented, and how large a space should a specific instance manage? These are not determined by the executable code, instead, determined by a piece of information on a disk called the partition table. The code reads and examines the partition table to make final decision. For us smart system designers, we insightfully waste a small piece of storage at the head of the harddisk in favor of the partition table, so to achieving such a beautiful result of late-binding, so a highly dynamic system. What a brilliant decision.
						</div>
					</div>
				</div>
			</div>

			<div class="table__row">
				<div class="table__cell itembrief">
					<div class="duallang">
						<div class="lang-cn2">单一二进制文件的好处</div>
						<div class="lang-en2">Benefits of a single binary</div>
					</div>
				</div>
				<div class="table__cell itemdetail">
					<h4>
						<div class="duallang">
							<div class="lang-cn2">这说的是什么意思？</div>
							<div class="lang-en2">What does it mean?</div>
						</div>
					</h4>
					<div class="duallang">
						<div class="lang-cn2">单一二进制文件，意思是我们应该尽力做到只提供一份二进制文件（或说可执行文件）给我们的客户，让这唯一一份文件来适应用户的不同使用环境。
						</div>
						<div class="lang-en2">Single binary, means we should strive to provide a single set of binary files(executable files) for all our users, and this set of binaries should be adaptable to all user environments.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">需要举一些反面的例子才能比较清楚地说明其含义。
						</div>
						<div class="lang-en2">Some contrary examples help clarify its meaning. 
						</div>
					</div>
					<ul>
						<li>
							<div class="duallang">
								<div class="lang-cn2">我们开发的一个软件分为基础版和专业版，不应该为基础版编译一个 EXE 文件，为专业版再编译一个 EXE 文件；相反，应该只编译一个 EXE 文件，根据用户填入的序列号来呈现基础版和专业版的不同功能。
								</div>
								<div class="lang-en2">If our software is marketed as Basic version and Pro version, we should NOT compile and EXE file for Basic, and another for Pro; instead, we should compile a single EXE, and it presents different features according to serial number provided by the end-user.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">如果我们的软件同时支持 Windows XP 和 Windows 10，那么，不要为这两个 OS 各自编译一份 EXE，而是用同一份 EXE 。在古老的 WinXP 上，我们仅仅调用老式的 API 来完成工作；而在新版 的 Win10 上，我们才去调用新版的 API 来达成新系统上的新功能。事实上，UFCOM 就是这么做的，它从 WinXP 一直支持到 Win10，而且设法做到了只提供一份二进制文件。
								</div>
								<div class="lang-en2">If our software supports Windows XP through Windows 10, we should NOT build two EXE files for each of the OS version; instead, build only one. On the older WinXP, we call only old system APIs; on the newer Win10, we call new APIs to achieve new features by the OS. Actually, UFCOM takes the very approach; it support WinXP through Win10, by a single set of binary files, with a bit effort from me.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">对于像 PT-850 这样的产品，单一二进制的原则依然适用。PT-850 其实是一个产品系列，包含很多种子型号。不同的子型号在硬件配置上有所差别，它们可能有不同型号的条码识读头，不同的无线通信模块，甚至不同的主板版本号（主板上有一些细微的硬件差别）。我的同事曾经有生成多份二进制的倾向，比如，给不带无线通信模块的编译一个内核，给带 GPRS 模块的编译一个内核，再给带 Wifi 模块的编译一个内核。好在我介入该项目后及时阻止了这种做法，并且将单一二进制原则一直保持到产品生命周期结束。
								</div>
								<div class="lang-en2">For a product like PT-850, this principle still applies. PT-850 is actually a series of sub-models. Different sub-models may have different scanner hardware, different wireless module(GPRS or Wifi), and even different mainboard versions with subtle hardware discrepancies. There had been trends from my co-workers to build its kernel into different variants, for example, one kernel for non-wireless model, one for GPRS model, and yet another for Wifi model. That bad trend was stopped by me as I got involved in this project, and I never allowed it to stray away until end of the product life.
								</div>
							</div>
						</li>
					</ul>
					<h4>
						<div class="duallang">
							<div class="lang-cn2">好处是什么？</div>
							<div class="lang-en2">What's the benefit?</div>
						</div>
					</h4>
					<div class="duallang">
						<div class="lang-cn2">为什么我要坚持单一二进制策略呢？我多年的亲身经验告诉我，它带来的好处实在是太多了，对用户端和开发者端都有诸多的好处。
						</div>
						<div class="lang-en2">Why am I insisting on single-binary strategy? My own experiences through these years reveals so many benefits of it, both at user side and at developer side.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">【用户端的好处】</div>
						<div class="lang-en2">【Benefits at user side】</div>
					</div>
					<ol>
						<li>
							<div class="duallang">
								<div class="lang-cn2">减少用户的选择负担。用户很可能不是 IT 专家，选择应该使用哪一份二进制（或软件安装包）对它可能有困难。比如，用户可能不清楚自己用的 Windows 版本是 XP 还是 7/8/10，不清楚自己的系统是 32 位的还是 64 位的。即使用户清楚，选择意味着更多犯错的可能性，用户也许不小心用了不匹配的版本，结果表现出软件故障让他一头雾水。
								</div>
								<div class="lang-en2">Relief the user from the burden of selection. Our users may not be IT experts, so picking an appropriate binary(or installer) may be difficult for them. For instance, some user may not know what operating system version he is using, Windows XP or 7/8/10, or not knowing whether his system is 32-bit or 64-bit. Even if he is clear all about these, making selection means possibility of making errors. User may accidentally pick an inappropriate version and see weird behavior appear, frustrated.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">降低用户的认知负担。用户可以简单地用一个软件名加一个版本号来清晰地辨识出我们的软件。由于实施了单一二进制策略，我们的软件安装包名称就可以很短，短却没有歧义，这样的软件在用户眼中无疑是极其出众的。
								</div>
								<div class="lang-en2">Reduce the cost of cognition. User can identify our software with a simple software name and a version number, no other hassles. Thanks to the single binary strategy, we can name the installer in very short words, what a relax to the user.
								</div>
							</div>
						</li>
					</ol>
					<div class="duallang">
						<div class="lang-cn2">【对开发者的好处】</div>
						<div class="lang-en2">【Benefits at developer side】</div>
					</div>
					<ol>
						<li>
							<div class="duallang">
								<div class="lang-cn2">让版本号变简洁。实施单一二进制策略，我们的版本号命名只需要由数字构成即可，没有奇奇怪怪的各种后缀。比如 UFCOM，它的最新版本就是 1.7.12，由三个数字构成，就是如此简洁无歧义。</div>
								<div class="lang-en2">Concise versioning. With single binary, our version number will consist only of numbers, no arcane suffixes.  For example, the latest version of UFCOM is 1.7.12, consisting of three numbers, concise and unambiguous.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">减轻测试人员的测试负担。在测试人员眼中，他的测试对象就是唯一的一样东西，而不是好几样不同的变体。当然，如果你将测试人员也想象成是用户的话，用户端得到的好处他们都能得到。
								</div>
								<div class="lang-en2">Reduce the burden of software tester(the QA team). From the perspective of the QA team, they test only a single object, not a bunch of variant. Of course, if you think of the QA team as your users, all user benefits apply to them.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">抑制源代码分支泛滥。
								</div>
								<div class="lang-en2">Inhibit source code forking contagion.
								</div>
							</div>
							<div class="duallang">
								<div class="lang-cn2">让我们看看不实施单一二进制会导致什么样的后果。许多缺乏经验的开发团队在决定开发一个新功能时，会倾向于将它们的代码进行一次永久分叉，然后在新分叉上加入新功能。这么做短期貌似会带来一点好处，新功能引入的 bug 不会影响到老代码。然而，长期来看这会变成灾难。他们的代码仓库中将会出现越来越多的无法自动同步改进的重复代码。为其中一份老代码的 bug 修正无法自动同步到其他的老代码副本中。开发者只能靠人力逐个去找出应该修正的副本并手工同步那个修正。更糟糕的是，没有人能够知道到底有多少个副本需要同步修正。是否它们已经全部被修正了，只能靠运气。当然，我知道如果团队能够坚持单一的代码源头，而仅仅是编译过程才生成不同的二进制文件，那么这个灾难并不会出现。我只是强调，坚持单一二进制是最彻底的解决方案。
								</div>
								<div class="lang-en2">Let's see the dark side of not going single binary. Many unorganized team tends to permanently fork their code base and add new features on that new fork. The short-term benefit is that bugs in new feature code does not cause harm to the old code base. However, that is a long-term disaster. There will be so many duplicated and unsyncable code in devteam's code repository. Fixing a bug in one of those old code copies DOES NOT automatically have it auto-fixed for other copies. Developers have to fix them manually, one by one. Even worse, no one knows exactly how many other copies need such fix. Whether all of them get fixed is determined by luck. Sure, I know that if the team can keep a single source base and compile into multiple binary variants, this disaster can be avoided. I just want to emphasize that going single binary is the most thorough approach.
								</div>
							</div>
						</li>
					</ol>
					<h4>
						<div class="duallang">
							<div class="lang-cn2">实施单一二进制有代价吗？</div>
							<div class="lang-en2">Any cost of sticking to single binary?</div>
						</div>
					</h4>
					<div class="duallang">
						<div class="lang-cn2">是的。不付出任何的代价，却想得到那么多单一二进制的好处，是不现实的。我们必须付出一些短期的利益来换取那些长远的好处。
						</div>
						<div class="lang-en2">Yes. It is not likely to attain so many benefits without any cost. We have to pay something in short-term in exchange for those long-term advantages.
						</div>
					</div>
					<ol>
						<li>
							<div class="duallang">
								<div class="lang-cn2">我们需要额外的工作来探测出我们所在的软硬件环境，因为我们已经主动要求将这个探测工作的负担从用户身上转移到我们自己的身上。</div>
								<div class="lang-en2">We need extra work to detect the hardware/software environment in which we are running, because we offer to transfer the burden of env-detection from our user to ourselves. 
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">我们需要经常重构我们的代码，以便让较少的代码能够完成较多场景下的工作。较少的代码，意味着较少的潜在 bug 以及较小的维护代价。重构，并不是简简单单地拷贝一份现有代码块后做出一点参数调整，相反，这是一项需要对原有架构进行优化甚至重新设计的工作，需要对于整个项目的全局视角才能做好。
								</div>
								<div class="lang-en2">We have to refactor our code often, so that we can use less code for more scenes. Less code implies less potential bugs and less maintenance cost in the future. Refactoring is not easy as well.  it needs deep understanding of our environment and the issues we need to solve. Refactoring is NOT simply copying a chunk of code tuning some running parameters, instead, it is about architectural optimization or even redesign, and that requires global insight into the whole project.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">单一二进制会让用户拿到的文件稍稍有点臃肿，因为里头的很多代码是多合一的，某些代码在具体用户的环境中可能一直会是休眠的状态。但我想这应该算是个次要问题，因为当今的计算机系统的存储一直在扩大。
								</div>
								<div class="lang-en2">Single binary would ship with a little bloated files to the user, because it is all-in-one code， and some code may stay dormant in a specific user environment. Anyway, I don't think it a big problem, because computer system storage is expanding fast nowadays.
								</div>
							</div>
						</li>
					</ol>
				</div> 
			</div>
			<div class="table__row">
				<div class="table__cell itembrief">
					<div class="duallang">
						<div class="lang-cn2">让代码跨平台运行，是提高代码质量的极好方法</div>
						<div class="lang-en2">More cross-platform, better code quality</div>
					</div>
				</div>
				<div class="table__cell itemdetail">
					<div class="duallang">
						<div class="lang-cn2">这里我主要指的是 C/C++ 代码，因为它是我在新大陆工作期间的主要编程语言。
						</div>
						<div class="lang-en2">I primarily refer to C/C++ code here, because it is my major programming language when I work for Newland.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">让代码跨平台的意思是，将我的源代码编译成能够在多种软件平台（比如 Windows, Linux）以及多种 CPU 架构（比如 x86, x64, ARM）上能够运行的二进制，并且想方设法地让各个平台上都将它们用上。你可能会问，像 UFCOM 这样的 Windows 专用软件，也能跨平台吗？我的观点其实很明确。虽然 UFCOM 整体上是 Windows-only 的，但它内部用到的很多功能模块是可以跨平台的。同样的道理，PT-850 的内核软件虽然被称为嵌入式软件，里头也有很多功能可以被提炼成通用的跨平台函数库。至于能够提炼到什么程度，就要看软件工程师抽象思维的水平了。<b>所谓抽象，就是总结不同事物之间的共性</b>。
						</div>
						<div class="lang-en2">Going cross-platform means: Compile my source code for multiple software platforms(Windows, Linux etc) and multiple CPU architectures(x86, x64, ARM etc), and find every opportunity to put them into actual use. You may ask, for Windows-specific software like UFCOM, how do I consider it cross-platform? OK, my idea is clear. Although UFCOM as a whole is Windows-only, but its many components can be made cross-platform. Same idea, while PT-850's kernel is considered embedded software, its many components can be cross-platform as well. As for how much of it can be distilled into platform-independent code, it relies on the software engineer's ability of abstract thinking. <strong>Abstract, is about finding common factors of different things.</strong> 
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">经过多年的跨平台软件思考与实践，我得出这样的结论：<strong>一个结构良好的软件，其中 90% 的部分应该是可重用的函数库，其余的 10% 是将那些函数库整合在一起形成最终软件样貌的黏合剂。</strong>
						</div>
						<div class="lang-en2">After many years of cross-platorm thinking and coding, I come up with such a conclusion: A piece of well structured software should consist of 90% of reusable libraries, and 10% of glue code that stitch the libraries to form the final software.
						</div>
					</div>
					<h4>
						<div class="duallang">
							<div class="lang-cn2">让代码跨平台的各种好处</div>
							<div class="lang-en2">Benefits of going cross-platform</div>
						</div>
					</h4>
					<div class="duallang">
						<div class="lang-cn2">能给我带来一种满足感。写一次代码就能在两个完全不同的系统中运行，就好像花一个面包的钱能买到两个面包，何乐而不为呢？ 
						</div>
						<div class="lang-en2">It brings me a feeling of fulfillment. Writing one piece of code and seeing it runs on two totally different systems, it's like getting two pieces of bread by paying for only one. Why not do it? </div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">在多个环境中运行，能够让代码得到更彻底的验证。比方说：
						</div>
						<div class="lang-en2">My code gets verified more thoroughly with multiple environments. For example: 
						</div>
					</div>
					<ul>
						<li>
							<div class="duallang">
								<div class="lang-cn2">我的代码能够被多个编译器验证。比如，有些代码写法的缺陷在 Visual C++ 眼中被忽略了，但却可以被 GNU gcc 检查出来。
								</div>
								<div class="lang-en2">My code gets checked in multiple compilers, for example, some coding flaw shrouded by Visual C++ may be uncovered by GNU gcc. 
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">32 位编译的代码，编译为 64 位后运行崩溃。这说明代码写法上很可能有错误，常见的如将一个指针值存储在一个 <tt>int</tt> 变量中。
								</div>
								<div class="lang-en2">Code runs well as 32-bit binary but fails when runs as 64-bit. This probably signifies a coding error, such as storing a pointer inside a <tt>int</tt> variable.</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">在强功能的平台上轻松调试与验证，在弱功能平台上放心地运行。想象一下，我需要为一台弱功能的嵌入式系统编写代码（比如 PT-850），它的 CPU, RAM, 和硬盘都很弱小，我应该怎么做最好呢？假定我要写的代码不是直接硬件相关的，那么，我一定会在 Windows 上先将代码的功能先实现，途中用 Visual C++ IDE 来调试它，写大把的测试案例在 Windows 即时运行。当所有能在 Windows 上进行的事都完成后，我将代码编译到真正目标平台上运行。我非常自信我的代码在目标平台上将会顺利运行，毕竟 C/C++ 是跨平台的语言嘛。
								</div>
								<div class="lang-en2">Debug and verify my program on more powerful platform with ease, and run them on less powerful platform with confidence. Consider, I'm coding for an embedded platform that has constrained CPU, RAM and disk with weak debugging facility(PT-850 is one case). What should I do then? Assuming that code is not hardware-dependent, I will definitely code the same feature on Windows first, so, I can debug my code with powerful Visual C++ IDE, write test cases to run from Windows instantly. When everything can be done on Windows is done, I compile my code for that real target system. With great confidence, it will run there without problem as well -- C/C++ is a cross-platform language after all.
								</div>
							</div>
						</li>
					</ul>
					<div class="duallang">
						<div class="lang-cn2">能从不同系统的差异中获得洞见。为了让我的代码尽量能够跨平台，我常常得细致地了解不同 OS 平台上系统 API 的使用方法，以便封装出统一形式的函数接口，这让我有机会对比不同系统设计的异同点，并思考它们各自的优点和缺点各在哪里。比如：通过考察 Windows 和 Linux 上线程创建函数的区别，我得出结论，线程创建函数接受一个 "user context" 参数是必须的，而给线程函数自身设计一个返回值的必要性就不大。
						</div>
						<div class="lang-en2">Get insights from different systems. In order to make my own code cross-platform, I often need to study various OS platform APIs so to encapsulate platform-specific code into uniform APIs. This gives me the chance of comparing underlying system to figure out what are good and bads of their designs. For instance, comparing threading API on Windows and Linux, I conclude that: It is vital for thread-creating function to accept a "user context" parameter, but not a must for the threading function itself to return a value.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">这是消除重复代码的一个重要手段，鲜明地实践了“别做重复的事”这个哲学思想。
						</div>
						<div class="lang-en2">It is an important way of eliminating code duplication, embracing the philosophy of "DON'T REPEAT YOURSELF".
						</div>
					</div>
					<h4>
						<div class="duallang">
							<div class="lang-cn2">还是老问题，这么做有代价吗？</div>
							<div class="lang-en2">Still the question, any cost?</div>
						</div>
					</h4>
					<div class="duallang">
						<div class="lang-cn2">确实有代价。我自己一路走来能够感受到这是一场印象深刻的苦难。难怪在新大陆时，我身边的绝大多数同事都没有像我这么做，我也没法强迫他们这么做，因为我不是他们的项目主管。
						</div>
						<div class="lang-en2">Yes, there is cost. I myself can feel the tribulation induced by this decision. No wonder most co-workers from Newland are reluctant to do this, and I cannot enforce my idea on them because I'm not their project manager. 
						</div>
					</div>
					<ul>
						<li>
							<div class="duallang">
								<div class="lang-cn2">需要费心去了解各种目标平台的编译器，至少要知道用什么样的编译开关才能生成各种文件类型，EXE/LIB/DLL 等。我还需要留意不同厂商的编译器、以及同厂商编译器不同版本之间行为的差异，遵循它们共有的特性，以便我的源代码能够适应所有这些编译器，比如，Visual C++ 和 gcc 处理 C++ 模版行为就有一些区别。对于无法回避的差别，得设计一些预处理宏来区分不同的编译器、或是将无法调和的代码拆散到不同的源文件中。
								</div>
								<div class="lang-en2">Quite some effort is required to get acquainted with various compilers involved. At least, I should know what compiler switches are responsible for generating EXE/LIB/DLL etc. I also need to know subtle difference between compilers from different vendors(or different versions of the same vendor), stick to common parts of them, so that my source code is compilable by all of them，e.g. Visual C++ and gcc exhibit some different behaviors when coping with C++ template code. For differences that I cannot bypass, I need to design some preprocessor macros to distinguish them, or, dissect unsharable parts into different source files.
								</div>
							</div>
						</li>
						<li>
							<div class="duallang">
								<div class="lang-cn2">最具挑战性的工作是如何管理工程文件。我们知道，为了将 .c/.cpp 编译成可执行文件，我们还需要工程文件。一个工程文件用于告知需要编译和链接哪些源文件，用什么选项来编译和链接，甚至还含有依赖性信息（需要先编译哪些“库”）。问题在于，不同编译器、甚至同一编译器的不同版本使用的工程文件千差万别。Visual C++ 6 用的 .dsp, Visual C++ 2005/2008 用的 .vcproj, Visual C++ 2010 及后续版本用的 .vcxproj, Linux 工程一般用 makefiles, 基于 ARM 的商业编译器有它们各自的专有格式。如果我要为五个目标平台编译代码，难道我得维护五份工程文件吗？这简直是个负担。
								</div>
								<div class="lang-en2">The most challenging work turns out to be project-file management. As we all know, to compile .c/.cpp files into executables, we need project files. A project file tells what source files to compile and link, what options to use for compiling and linking, and even its dependencies(what libraries to build first etc). The problem is, project files from different compilers or different compiler versions are heterogenous. Visual C++ 6 uses .dsp, Visual C++ 2005/2008 uses .vcproj, Visual C++ 2010 and later uses .vcxproj, Linux projects use makefiles, ARM-based commercial compilers use their proprietary formats. If I want to compile for five target platforms, do I need to maintain five project files? What a burden.
								</div>
							</div>
							<div class="duallang">
								<div class="lang-cn2">因此我决定使用自己的工程文件格式，基于 GMU 的 makefiles 。我的典型工程管理模式是这样的：使用两组工程文件，一组是 Visual C++ 的工程文件，这让我在开发阶段便于编辑代码和可视化调试；另一组是 GMU makefiles，负责所有平台上的命令行编译。本文后头有对 GMU 的更详细介绍。虽然不算完美，但还算是总体能够接受的解决方案。
								</div>
								<div class="lang-en2">So I decided to employ my own project file, that is, makefiles based on GMU. My typical project management pattern is: Use two sets of project files, one is Visual C++ project file that ease code editing and visual debugging on Windows; the other is GMU makefiles that is responsible for command-line building for all platforms. I'll talk about GMU in more detail later. Although not perfect, it reaches a state of overall acceptance.
								</div>
							</div>
						</li>
					</ul>
				</div>
			</div>
			
			<div class="table__row">
				<div class="table__cell itembrief">
					<div class="duallang">
						<div class="lang-cn2">封装可以解决很多棘手的问题</div>
						<div class="lang-en2">Encapsulation solves many tough problems</div>
					</div>
				</div>
				<div class="table__cell itemdetail">
					<div class="duallang">
						<div class="lang-cn2">封装，是一个巨大的话题。软件世界里除了数学和算法以外，其他的看起来好像都是封装。我在软件行业里头学习得越多，就越感受到封装的神奇。
						</div>
						<div class="lang-en2">Encapsulation is a gigantic topic. It seems that the software world is all about encapsulation besides mathematics and algorithms. The more I learn in software, the more I find it fantastic. 
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">让我就举一个例子吧。早年有一个让我苦恼了好一阵的小问题，这是有关 Windows 线程函数的一个问题。Windows 应用程序要创建线程的话，用哪个函数最好呢？根据 Windows 系统大牛 Jeffrey Richter 的说法，用 C 运行库函数 _beginthreadex 是最好的。但不知为何微软在定义此函数时干了件画蛇添足的事情，要求作为参数的线程函数是 <tt>__stdcall</tt> 类型的，而非 C/C++ 默认的 <tt>__cdecl</tt> 类型。这给我们带来的麻烦是，我们得为函数原型加上 __stdcall 修饰。为什么说它是个麻烦呢？因为我总是希望我的 C/C++ 代码是跨平台的，而其他平台（比如 Linux）根本就不识别这个 <tt>__stdcall</tt> 修饰。那怎么办呢？只好为其他所有编译器找个地方将 __stdcall 给 #define 成空符号。这不是多了一整套的累赘嘛！
						</div>
						<div class="lang-en2">Let me cite just one example. In early days, I had been bothered by a small issue for quite a while, which was about Windows thread function. When Windows application needs to create a thread, which thread creating function is the best? According to Windows system guru Jeffrey Richter, C Runtime function _beginthreadex is the best. But, Microsoft places an meaningless limitation on this API, who requires that the threading function must be of type <tt>__stdcall</tt>, instead of the default <tt>__cdecl</tt>. It brought me the hassle of adding <tt>__stdcall</tt> decoration to my threading functions. Why is it a hassle? Because I said I always want my code to be cross-platform, but all other platform(Linux for instance) does not recognize this <tt>__stdcall</tt> stuff. Then what shall I do? I had to <tt>#define</tt> all appearance of <tt>__stdcall</tt> to empty token for all other compilers. A whole bunch of verbosity!
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">几年后一天我突然想通了。为什么不给 _beginthreadex 来一层封装呢？现在我是封装者，我提供的函数叫 winCreateThread，这个 winCreateThread 接受的用户线程函数是自然的 <tt>__cdecl</tt> 类型；我当然不能把用户的线程函数直接传给 _beginthreadex（因为函数原型不匹配），我需要把自己准备的一个 __stdcall 类型的 wrapper-function 传给 _beginthreadex；我的 wrapper-function 开始执行后，它将转而去执行用户的线程函数，这样，用户的线程函数就跑起来了。一个小小的封装完美解决问题！
						</div>
						<div class="lang-en2">One day after several years, I got enlightened. Why not make an encapsulation for _beginthreadex? Now I am the encapsulator, I provide a new API called winCreateThread. This winCreateThread accepts user's threading function in the natural <tt>__cdecl</tt> form; of course I will not pass user's threading function to _beginthreadex(due to prototype mismatch), instead, I pass a __stdcall typed wrapper-function to _beginthreadex; and finally, as soon as my wrapper-function starts running, it in turn calls user's threading function. So, user's threading function finally runs. A small encapsulation solves it perfectly!
						</div>
					</div>
				</div>
			</div>
		</div>
		
	</div> <!-- end: lv2content of PT850 -->


	<h2 class="h2title">
		<div class="lang-cn0">GMU - 一直伴随我前进的持续集成系统</div>
		<div class="lang-en0">GMU - Continuous Integration all the way with me</div>
		<div class="stripe"></div>
	</h2>

	<div class="lv2content">

		<div class="duallang">
			<div class="lang-cn2">你很可能是第一次听说 GMU，这并不奇怪，因为它是我自己开发的一套系统。最早时候我给它起的名字是 GnumakeUniproc，完整意思 GNU make universal process，写起来和念起来都很长，因此后来我就简称它 GMU 了。从名字上可以看出，这个系统是基于 GNU make 的，既然是 "make"，肯定是用来编译一个 C/C++ 工程的。没错，确实如此。那我用了它多久呢？很久，从 2006 年一直到 2008 年 UFCOM 完成。那就其他的替代品吗？呃……我觉得很难找到替代品，因为一路走来我有很多定制化的需求需要用 GMU 来满足。
			</div>
			<div class="lang-en2">It is probably the first time you hear GMU, because it is a system developed by me. At the beginning, I gave it the name GnumakeUniproc, with the full meaning "GNU make universal process", long and verbose, right? So I later give it a brief name GMU. As the name implies, this system is based on GNU make. Since it is "make", it must serve the purpose of compiling some C/C++ projects. Right, you get it. Then how long have I used it? Very long, from year 2006 to 2018, the year I finished UFCOM. Can I have some alternatives? I'm afraid not, because so many customized requirements have to be accomplished with GMU.
			</div>
		</div>
		
		<div class="itembrief">
			<div class="duallang">
				<div class="lang-cn2">GMU 这个东西最初是怎么在我头脑里产生的？</div>
				<div class="lang-en2">How does GMU come into being in the first place?</div>
			</div>
		</div>
		<div class="itemdetail">
			<div class="duallang">
				<div class="lang-cn2">我可以举出很多理由，但如果一直追溯到最源头，我发现是我的一个本能在驱使我这么做：我希望我写的代码能够在我所遇见过的所有平台上都能运行，这样的话我才能感受到物尽其用。所谓的平台，可以从硬件和软件两个角度进行划分。硬件角度有 Intel x86 and x64, ARM，MIPS, RISC-V 等。软件角度有 Windows, WinCE, Linux, 以及各种专门的嵌入式 OS。从 2003 年开始，我就意识到这个问题了，因为当时 PT-850 的很多代码已经需要同时被编译成 ARM 的和 PC Windows 的，而同时用两套工程管理文件常常出现不同步的问题。而且，接下来的几年中，我们公司的产品还要面对更多样化的平台，比如 ARM-Linux 和 ARM-WinCE 。没错，我的原始动机是，不要为每一个目标平台各自维护一份工程文件，而是共用一份工程文件。
				</div>
				<div class="lang-en2">I could cite many reasons. But if I trace them back to origin, I find that it is my "instinct" driving me do this. That is, I hope my code can be run on all platforms I have encountered. So I can feel I have got the most out of my effort writing those code. The so called platforms, can be viewed from two aspects: Hardware, like Intel x86 and x64, ARM, MIPS, RISC-V etc. Software: Windows, WinCE, Linux, and all kinds of embedded OS. Since 2003, I have been aware of such and situation because many of PT-850's code is compiled for both ARM and PC Windows(as I've mentioned before), and using two sets of project management files often went out of sync. Moreover, In the next years, more platforms like ARM-Linux and ARM-WinCE come into play in our company product. Yes, my initiative is: Don't maintain N project files for N platforms, instead, a single project file across all platforms.
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">既然已经牵涉到 Linux ，工程管理文件不可避免地要用到 makefile ，这已经是 Unix 世界二十多年的传统了。既然需要写 makefile，为什么不用 makefile 来一并管理所有平台的 C/C++ 代码构建呢？这是我在 2006 年时能够想到的唯一可行方案。我得承认，当时我还没接触过 Python、Ruby ，因此错过了基于高级脚本语言的更有潜力的方案。
				</div>
				<div class="lang-en2">Since we've come to Linux, I can inevitably come across makefiles, which is the traditionally way in Unix world for 20+ years. So why not manage all-platform building with makefiles? That was the only viable solution I came up with back in 2006. I have to confess, I did not know Python or Ruby back then, so I missed the possibility of potential solutions using those high-level scripting languages.
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">GNU make 到底能多大程度地满足我的需求呢？这个需要一番调查。我的许多同事可没像我这么想，因为他们一开始使用 makefile 的姿势就不对。比方说，要编译一些 Linux 工程时，他们会为每一个工程手工编写各自的一个 makefile，然后呢，每次执行 <tt>make</tt> 之前，他们会先敲 <tt>make clean</tt> 来清除掉旧的二进制文件。简直犯傻，如果每次 make 都要清除旧文件，那使用 makefile 的好处在哪里呢？干脆用 Bash 脚本不是更直接吗？
				</div>
				<div class="lang-en2">How does GNU make fit well to my needs? I had to investigate it first. Many of my colleagues did not think of it, because they just used makefiles poorly. For example, for Linux C/C++ projects, they handcrafted one makefile for each single project(big one or small one), and for each <tt>make</tt> execution, they run <tt>make clean</tt> first to clean all "stale" binary files. Yuck, what's the benefit of using makefile if he cleans everything before each run. A Bash script could be a better choice then.
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">为了找到正确使用 makefile 的方法，我开始仔细阅读 <a href="https://www.gnu.org/s/make/manual/make.html">GNU make 官方手册</a>，这时我才发现我之前对它的功能了解还不到 10%。剩余 90% 的高级功能让我看到了实现跨平台 makefile 工程文件的希望。
				</div>
				<div class="lang-en2">To find the correct way of using make, I started reading <a href="https://www.gnu.org/s/make/manual/make.html">official GNU make manual</a>(was version 3.79 back then in 2006), and found that I knew less than 10% of its full features. The remaining 90% feature brought me the hope of accomplishing cross-platform makefiles.
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">最后，我没有失望。我设法将 GMU 用到了我后来所有的 C/C++ 工程中。所有需要自动构建的工程，都是用GMU 来组织的。当然，在不断地延伸 GMU 的使用场合的过程中，我无数多次根据实际需要对它进行了大大小小改进。
				</div>
				<div class="lang-en2">Finally, I'm not disappointed. I have managed to use GMU in all my C/C++ projects. Especially, for projects that need auto-build, they are all built around GMU. Of course, GMU has gone through numerous big and small improvements.
				</div>
			</div>
		</div>

		<div class="itembrief">
			<div class="duallang">
				<div class="lang-cn0">简要描述 GMU 的功能和特点</div>
				<div class="lang-en0">GMU features and highlights in brief</div>
			</div>
		</div>
		<div class="itemdetail">
			<div class="imagerow imagerow--textandimage">
				<div>
					<div class="duallang">
						<div class="lang-cn2">GMU 在 Linux 上构建完一个小工程。</div>
						<div class="lang-en2">GMU on Linux building a small project.</div>
					</div>
					<img src="res/gmu-linux-done.png" />
				</div>
				<div>
					<div class="duallang">
						<div class="lang-cn2">UFCOM 构建完成后的屏幕显示。</div>
						<div class="lang-en2">Screenshot at end of UFCOM building.</div>
					</div>
					<img src="res/gmu-ufcom-done.png" />
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">GMU 可以被认为是一套基于 GNU make 的框架，它使得最终用户的 makefile 变得很简洁。GMU 的核心理念是：用户被分为两层。第一层是编译器配置作者以及插件作者，第二层是最终用户。
				</div>
				<div class="lang-en2">GMU can be considered as a framework around GNU make, by whom end-user's makefile becomes very concise. The core idea of GMU is, user is two-tiered. Tier one is the complier-config author and the plugin author; tier two is the end-user.
				</div>
			</div>
			<ul>
				<li>
					<div class="duallang">
						<div class="lang-cn2">处于第二层的最终用户，是 C/C++ 程序员。他们需要只编写简单的“GMU makefiles”来告知工程组织必要的信息，比如，.c/.cpp 源码列表、.h 头文件搜索路径、输出文件名等。重复性的脏活累活交由第一层来处理。
						</div>
						<div class="lang-en2">The end-user at tier two is the C/C++ programmer who also needs to manage project files. Using GMU, he only needs to create simple "GMU makefiles", providing project unique information in his makefile, such as .c/.cpp file list, .h search paths, output filename etc. Other repetitive dirty works should be handled by tier one.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">第一层的 GMU 代码懂得构建过程的细节，它们指出构建过程应该调用什么样的编译和链接命令，包括使用什么样的编译和链接开关，将 obj 和 exe 输出放到哪个目录中，如何生成 C/C++ 头文件依赖规则等。
						</div>
						<div class="lang-en2">Tier one GMU codes knows every detail of the build process. They determine what compile and link command to apply, including what compile/link options to use, where to place output obj/exe files, how to generate dependency rules for C/C++ header files.
						</div>
					</div>
				</li>
			</ul>
			<div class="duallang">
				<div class="lang-cn2">总言之，GMU 核心代码和第一层代码承揽越多的工作，最终用户的 makefile 就能够越简洁同时还能越强大。
				</div>
				<div class="lang-en2">In general, more work is done by GMU core and Tier One code, more concise and more power makefiles will end-user achieve.
				</div>
			</div>
			<div class="duallang">
				<div class="lang-cn2">现在简要列举几条最终用户能够从 GMU 得到的功能：</div>
				<div class="lang-en2">Now I will cite several features end-user will get from GMU:</div>
			</div>
			<ol>
				<li>
					<div class="duallang">
						<div class="lang-cn2">自动生成头文件依赖关系。意即，如果有某个 .h 被修改，下一次运行 umake 时相关的 .c/.cpp 将被重新编译。注：umake 是 GMU makefile 的启动命令。
						</div>
						<div class="lang-en2">Auto-generate header file dependency. That is, if some .h file is modified, relevant .c/.cpp will get re-compiled on next umake. Memo: umake is the startup command for GMU makefile.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">Debug/Release 的编译输出自动被放在不同目录中，针对不同目标平台的编译输出也会分目录存放。这意味着，切换不同的“构建变体”时，无需 clean 掉其他变体的输出。
						</div>
						<div class="lang-en2">Debug/Release output is separated in different folders, so do outputs for different target platform. That means, when switching to a new build-variant, you don't have to clean output of other variants.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">用 umake 启动参数即可控制是否显示具体的编译/链接命令，而不用修改 makefile 自身。不显示会让屏幕输出显得干净，要求显示则能够帮助诊断问题。
						</div>
						<div class="lang-en2">Control whether to show detail compile/link command-line via umake command options, no need for modifying makefile itself. Suppressing it makes screen output concise, and requiring output helps diagnosing.
						</div>
					</div>
				</li>
				<li>
					<div class="duallang">
						<div class="lang-cn2">父工程自动探测子工程的输出文件名，并正确引用之。假定父工程生成 A.EXE ，子工程生成 B.LIB，父工程需要链接 B.LIB。GMU makefile 能够描述 A 和 B 的父子关系，并且自动链接 B 的输出。B 工程的输出名称由 B 自行决定，A 将自动探测得知。这是 GMU 核心层的一个特色功能，父工程通过一个专门的 "make target" 在运行过程当场查得子工程的输出文件名，这就避免了将子工程的输出文件名硬编码在父工程的 makefile 中。
						</div>
						<div class="lang-en2">The parent project can detect child project's output filename, and refers to that name correctly. For example, the parent project generates A.EXE, the child generates B.LIB. GMU makefile has a way to describe parent-child relationship between the two, and have A automatically links B's output. B's output filename is determined by solely by B's makefile, and A will detect it automatically. This is a special feature from GMU core. The parent project queries child project's output filename at runtime via a special "make target", eliminating the requirement of hardcoding child project's output filename inside parent project's makefile.
						</div>
					</div>
					<div class="duallang">
						<div class="lang-cn2">我一直认为这个输出文件名自动查询功能非常有用。想想看下面的情况：如果一个 LIB 工程要被十个父工程引用如何？如果子工程有四种输出变体（由 x86/x64 和 Debug/Release）组合而成，父工程要用四个不同的文件名来引用子工程的输出，将导致 makefile 变得多么繁琐？
						</div>
						<div class="lang-en2">I always deem this output-name-query feature very useful. Please think of the following situations: What if a LIB project is referred to by TEN parent projects? If we need four child project output variants by x86/x64 and Debug/Release, what hard work will it be to refer to those four output filenames in the parent project?
						</div>
					</div>
				</li>
			</ol>
		</div>

	</div> <!-- end: lv2content of GMU -->

	<h1 class="h1title">
		<div class="lang-cn0">最近一年在家学习的新知</div>
		<div class="lang-en0">New knowledge learned at home in the past year</div>
		<div class="stripe"></div>
	</h1>

	<div class="lv2content">
		<div class="duallang">
			<div class="lang-cn2">Sec 5.1 中文</div>
			<div class="lang-en2">Sec 5.1 English</div>
		</div>
	</div>

	<h1 class="h1title">
		<div class="lang-cn0">(666) 最近一年在家学习的新知</div>
		<div class="lang-en0">(666) New knowledge learned at home in the past year, Long, long2, long3, long4 section title.</div>
		<div class="stripe"></div>
	</h1>

	<div class="lv2content">
		<div class="duallang">
			<div class="lang-cn2">Sec 6.1 中文</div>
			<div class="lang-en2">Sec 6.1 English</div>
		</div>
	</div>

	<h1 class="h1title">
		<div class="lang-cn0">(777) 最近一年在家学习的新知</div>
		<div class="lang-en0">(777) New knowledge learned at home in the past year</div>
		<div class="stripe"></div>
	</h1>

	<div class="lv2content">
		<div class="duallang">
			<div class="lang-cn2">Sec 7.1 中文</div>
			<div class="lang-en2">Sec 7.1 English</div>
		</div>
	</div>

</div> <!-- .maincol final one -->

</div> <!-- .globalframe -->
</body>

		<div class="duallang">
			<div class="lang-cn2"></div>
			<div class="lang-en2"></div>
		</div>
